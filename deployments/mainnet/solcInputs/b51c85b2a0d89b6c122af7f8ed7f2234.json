{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/AutomationBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract AutomationBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/AutomationCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AutomationBase.sol\";\nimport \"./interfaces/AutomationCompatibleInterface.sol\";\n\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/automator/AutomationBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract AutomationBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}"
    },
    "contracts/automator/AutomationCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AutomationBase.sol\";\nimport \"./interfaces/AutomationCompatibleInterface.sol\";\n\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}"
    },
    "contracts/automator/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}"
    },
    "contracts/automator/LBActiveManagerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '../LB/interfaces/ILBPair.sol';\nimport '../interfaces/ILBStrategy.sol';\n\nimport '@chainlink/contracts/src/v0.8/AutomationCompatible.sol';\n\n/// @title LBActiveStratManager V2\n/// @author SteakHut Finance\n/// @notice contract to enable rebalances of the underlying strategy using existing parameters\n/// @notice this strategy will chase an active bin once it goes within x number bins of current range\n/// @notice this strategy will also perform a rebalance once it becomes one sided\ncontract LBActiveStratManagerActiveV2 is\n    Ownable,\n    AutomationCompatibleInterface\n{\n    using SafeERC20 for IERC20;\n    address public immutable strategyAddress;\n    uint256 public binOffset;\n\n    //tracks rebalances and attempts to ~equal weight on next rebalance\n    bool public isTokenXWeighted;\n    bool public isTokenYWeighted;\n    uint256 public centerOffset;\n\n    //harvesting params\n    uint256 public lastTimestamp;\n    uint256 public period = 86400; //48 hours\n    address public gasCaller;\n\n    /// -----------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------\n\n    constructor(\n        address _strategyAddress,\n        uint256 _binOffset,\n        uint256 _centerOffset\n    ) {\n        strategyAddress = _strategyAddress;\n        binOffset = _binOffset;\n        centerOffset = _centerOffset;\n    }\n\n    /// -----------------------------------------------------------\n    /// Manager Functions\n    /// -----------------------------------------------------------\n\n    /// @notice Updates binOffset\n    /// @param _binOffset new bin offset.\n    function setBinOffset(uint256 _binOffset) external onlyOwner {\n        require(_binOffset >= 0, 'Manager: Bin offset too small');\n        binOffset = _binOffset;\n    }\n\n    /// @notice Updates centerOffset\n    /// @param _centerOffset new center offset.\n    function setCenterOffset(uint256 _centerOffset) external onlyOwner {\n        require(_centerOffset >= 0, 'Manager: Center offset too small');\n        centerOffset = _centerOffset;\n    }\n\n    /// @notice Updates the minimum period between harvests\n    /// @param _period new minimum period.\n    function setPeriod(uint256 _period) external onlyOwner {\n        require(_period > 3600, 'Manager: Period too small');\n        period = _period;\n    }\n\n    /// @notice Rescues funds stuck\n    /// @param _token address of the token to rescue.\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n\n    /// @notice manual rebalance underlying position\n    function manualRebalance() external onlyOwner {\n        //set the weightings to be neutral as manual rebalance\n        isTokenYWeighted = false;\n        isTokenXWeighted = false;\n\n        ILBStrategy(strategyAddress).executeRebalance();\n    }\n\n    /// -----------------------------------------------------------\n    /// View / Pure Functions\n    /// -----------------------------------------------------------\n\n    /// @notice returns the minimum and maximum bin currently used by the underlying strategy\n    function _checkMinMaxActiveBins(\n        uint256[] memory activeBins\n    ) public pure returns (uint256 minBin, uint256 maxBin) {\n        //do a first run and set min bin to the first item\n        bool isFirstRun = true;\n\n        for (uint256 i; i < activeBins.length; i++) {\n            if (activeBins[i] < minBin || isFirstRun) {\n                minBin = activeBins[i];\n                isFirstRun = false;\n            }\n            if (activeBins[i] > maxBin) {\n                maxBin = activeBins[i];\n            }\n        }\n    }\n\n    /// -----------------------------------------------------------\n    /// Chainlink Functions\n    /// -----------------------------------------------------------\n\n    /// @notice Chainlink Check Upkeep Function\n    /// @notice checks to moves liquidity around the active bin once binOffset is achieved\n    /// @notice checks if enough time has passed to perform a harvest only\n    function checkUpkeep(\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory performData)\n    {\n        upkeepNeeded = false;\n\n        //fetch all the active bins in the strategy\n        uint256[] memory activeBins = ILBStrategy(strategyAddress)\n            .strategyActiveBins();\n        (uint256 minBin, uint256 maxBin) = _checkMinMaxActiveBins(activeBins);\n\n        //get the center of the active bins\n        uint256 binLength = activeBins.length;\n        uint256 centerBin = binLength / 2;\n        uint256 minCenterBin = activeBins[centerBin - centerOffset];\n        uint256 maxCenterBin = activeBins[centerBin + centerOffset];\n\n        //fetch the current activeId of the lb pair\n        address _lbPair = ILBStrategy(strategyAddress).lbPair();\n        (, , uint256 activeId) = ILBPair(_lbPair).getReservesAndId();\n\n        //if the active bin is within binOffset of the active bin rebalance the underlying strategy\n        if (activeId <= minBin + binOffset) {\n            upkeepNeeded = true;\n        }\n        if (activeId >= maxBin - binOffset) {\n            upkeepNeeded = true;\n        }\n\n        //if the ratio is skewed rebalance to get ratio back to equal weight\n        if (\n            (activeId <= minCenterBin && isTokenYWeighted) ||\n            (activeId >= maxCenterBin && isTokenXWeighted)\n        ) {\n            //requires upkeep to equal weight bins\n            upkeepNeeded = true;\n        }\n\n        //require an upkeep if there has been minimum time between harvests\n        if (block.timestamp > lastTimestamp + period) {\n            upkeepNeeded = true;\n        }\n\n        performData; //silence unused parameter\n    }\n\n    /// @notice Chainlink Perform Upkeep Function\n    /// @notice moves liquidity around the active bin once binOffset is achieved\n    /// @notice harvest if enough time has passed to perform a harvest only\n    function performUpkeep(bytes calldata) external override {\n        //get the underlying lbPair and activeId\n        address _lbPair = ILBStrategy(strategyAddress).lbPair();\n        (, , uint256 activeId) = ILBPair(_lbPair).getReservesAndId();\n\n        //fetch the active bins in the strategy\n        uint256[] memory activeBins = ILBStrategy(strategyAddress)\n            .strategyActiveBins();\n\n        // check the min and max active bins\n        (uint256 minBin, uint256 maxBin) = _checkMinMaxActiveBins(activeBins);\n\n        //get the center of the active bins\n        uint256 binLength = activeBins.length;\n        uint256 centerBin = binLength / 2;\n        uint256 minCenterBin = activeBins[centerBin - centerOffset];\n        uint256 maxCenterBin = activeBins[centerBin + centerOffset];\n\n        //revalidating the upkeep in the performUpkeep function\n        //if the active bin is within binOffset of the active bin rebalance the underlying strategy\n        //idle strategy funds are put to work on the next rebalance\n        //we dont need to check bin limit as funds will always be the underlying bin length\n        if (activeId <= minBin + binOffset || activeId >= maxBin - binOffset) {\n            //the liquidty upon this rebalance will be skewed so turn on trigger switch for next\n            if (activeId <= minBin + binOffset) {\n                //strategy is token X weighted\n                isTokenXWeighted = true;\n                isTokenYWeighted = false;\n            }\n            if (activeId >= maxBin - binOffset) {\n                //strategy is token Y weighted\n                isTokenXWeighted = false;\n                isTokenYWeighted = true;\n            }\n\n            //rebalance keeping the same parameters as before\n            //does not require a harvest as executeRebalance handles this\n            ILBStrategy(strategyAddress).executeRebalance();\n        } else if (\n            (activeId <= minCenterBin && isTokenYWeighted) ||\n            (activeId >= maxCenterBin && isTokenXWeighted)\n        ) {\n            //reset the weighting switch\n            isTokenYWeighted = false;\n            isTokenXWeighted = false;\n\n            //rebalance keeping the same parameters as before\n            //does not require a harvest as executeRebalance handles this\n            ILBStrategy(strategyAddress).executeRebalance();\n        } else {\n            //harvest rewards from strategy; can be called anytime\n            _harvest();\n        }\n    }\n\n    /// -----------------------------------------------------------\n    /// Internal Functions\n    /// -----------------------------------------------------------\n\n    /// @notice executes a harvest of the associated strategy\n    function _harvest() internal {\n        ILBStrategy strategy = ILBStrategy(strategyAddress);\n        strategy.harvest();\n\n        //update the last harvest timestamp\n        lastTimestamp = block.timestamp;\n    }\n\n    /// -----------------------------------------------------------\n    /// END\n    /// -----------------------------------------------------------\n}\n"
    },
    "contracts/common/StratManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\n\ncontract StratManager is Ownable, Pausable {\n    /// @dev SteakHut Contracts:\n    /// {keeper} - Address to manage a few lower risk features of the strat incl rebalancing\n    /// {strategist} - Address of the strategy author/deployer where strategist fee will go.\n    /// {vault} - Address of the vault that controls the strategy's funds.\n    /// {joeRouter} - Address of exchange to execute swaps.\n    address public keeper;\n    address public joeRouter;\n    address public immutable vault;\n\n    /// -----------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------\n    event SetKeeper(address keeper);\n    event SetJoeRouter(address joeRouter);\n\n    /**\n     * @dev Initializes the base strategy.\n     * @param _keeper address to use as alternative owner.\n     * @param _joeRouter router to use for swaps\n     * @param _vault address of parent vault.\n     */\n    constructor(address _keeper, address _joeRouter, address _vault) {\n        keeper = _keeper;\n        joeRouter = _joeRouter;\n        vault = _vault;\n    }\n\n    // checks that caller is either owner or keeper.\n    modifier onlyManager() {\n        require(msg.sender == owner() || msg.sender == keeper, '!manager');\n        _;\n    }\n\n    /// @notice Updates address of the strat keeper.\n    /// @param _keeper new keeper address.\n    function setKeeper(address _keeper) external onlyManager {\n        require(_keeper != address(0), 'StratManager: 0 address');\n        keeper = _keeper;\n\n        emit SetKeeper(_keeper);\n    }\n\n    /// @notice Updates router that will be used for swaps.\n    /// @param _joeRouter new joeRouter address.\n    function setJoeRouter(address _joeRouter) external onlyOwner {\n        require(_joeRouter != address(0), 'StratManager: 0 address');\n        joeRouter = _joeRouter;\n\n        emit SetJoeRouter(_joeRouter);\n    }\n\n    /// @notice Function to synchronize balances before new user deposit.\n    /// Can be overridden in the strategy.\n    function beforeDeposit() external virtual {}\n}\n"
    },
    "contracts/interfaces/ILBStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface ILBStrategy {\n    /// @notice The liquidity parameters, such as:\n    /// @param tokenX: The address of token X\n    /// @param tokenY: The address of token Y\n    /// @param pair: The address of the LB pair\n    /// @param binStep: BinStep as per LB Pair\n    /// @param deltaIds: the bins you want to add liquidity to. Each value is relative to the active bin ID\n    /// @param distributionX: The percentage of X you want to add to each bin in deltaIds\n    /// @param distributionY: The percentage of Y you want to add to each bin in deltaIds\n    /// @param idSlippage: The slippage tolerance in case active bin moves during time it takes to transact\n    struct StrategyParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        address pair;\n        uint16 binStep;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        uint256 idSlippage;\n    }\n\n    function deltaIds() external view returns (int256[] memory deltaIds);\n\n    function distributionX()\n        external\n        view\n        returns (uint256[] memory distributionX);\n\n    function distributionY()\n        external\n        view\n        returns (uint256[] memory distributionY);\n\n    function idSlippage() external view returns (uint256);\n\n    function vault() external view returns (address);\n\n    function lbPair() external view returns (address);\n\n    function setKeeper(address _keeper) external;\n\n    function keeper() external view returns (address);\n\n    function strategyPositionAtIndex(\n        uint256 _index\n    ) external view returns (uint256);\n\n    function strategyPositionNumber() external view returns (uint256);\n\n    function checkProposedBinLength(\n        int256[] memory proposedDeltas,\n        uint256 activeId\n    ) external view returns (uint256);\n\n    function addLiquidity(\n        uint256 amountX,\n        uint256 amountY,\n        uint256 amountXMin,\n        uint256 amountYMin\n    ) external returns (uint256[] memory liquidityMinted);\n\n    function binStep() external view returns (uint16);\n\n    function balanceOfLiquidities()\n        external\n        view\n        returns (uint256 totalLiquidityBalance);\n\n    function removeLiquidity(\n        uint256 denominator\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function tokenX() external view returns (IERC20);\n\n    function tokenY() external view returns (IERC20);\n\n    function harvest()\n        external\n        returns (uint256 amountXReceived, uint256 amountYReceived);\n\n    function earn() external;\n\n    function retireStrat() external;\n\n    function panic() external;\n\n    function pause() external;\n\n    function unpause() external;\n\n    function paused() external view returns (bool);\n\n    function joeRouter() external view returns (address);\n\n    function binHasYLiquidity(\n        int256[] memory _deltaIds\n    ) external view returns (bool hasYLiquidity);\n\n    function binHasXLiquidity(\n        int256[] memory _deltaIds\n    ) external view returns (bool hasXLiquidity);\n\n    function beforeDeposit() external;\n\n    function rewardsAvailable()\n        external\n        view\n        returns (uint256 rewardsX, uint256 rewardsY);\n\n    function executeRebalance(\n        int256[] memory _deltaIds,\n        uint256[] memory _distributionX,\n        uint256[] memory _distributionY,\n        uint256 _idSlippage\n    ) external returns (uint256 liquidityAfter);\n\n    function executeRebalance()\n        external\n        returns (uint256 amountX, uint256 amountY);\n\n    function checkLengthsPerformRebalance() external;\n\n    function strategyActiveBins()\n        external\n        view\n        returns (uint256[] memory activeBins);\n\n    function getBalanceX() external view returns (uint256);\n\n    function getBalanceY() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IWrappedNative.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IWrappedNative {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}"
    },
    "contracts/interfaces/IYakRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IYakRouter {\n    struct FormattedOffer {\n        uint256[] amounts;\n        address[] adapters;\n        address[] path;\n        uint256 gasEstimate;\n    }\n\n    struct Trade {\n        uint256 amountIn;\n        uint256 amountOut;\n        address[] path;\n        address[] adapters;\n    }\n\n    function findBestPath(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _maxSteps\n    ) external view returns (FormattedOffer memory);\n\n    function swapNoSplit(\n        Trade calldata _trade,\n        address _to,\n        uint256 _fee\n    ) external;\n\n    function swapNoSplitFromAVAX(\n        Trade calldata _trade,\n        address _to,\n        uint256 _fee\n    ) external payable;\n\n    function swapNoSplitToAVAX(\n        Trade calldata _trade,\n        address _to,\n        uint256 _fee\n    ) external;\n}\n"
    },
    "contracts/LB-periph/JoeV2PeripheryErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../LB/LBErrors.sol\";\n\n/** LiquidityAmounts Errors */\n\nerror LiquidityAmounts__LengthMismatch();"
    },
    "contracts/LB-periph/LiquidityAmounts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../LB/libraries/Math512Bits.sol\";\nimport \"../LB/libraries/BinHelper.sol\";\nimport \"../LB/libraries/Constants.sol\";\nimport \"../LB/libraries/SafeCast.sol\";\nimport \"../LB/interfaces/ILBPair.sol\";\nimport \"../LB/interfaces/ILBToken.sol\";\n\nimport \"./JoeV2PeripheryErrors.sol\";\n\n/// @title Liquidity Book periphery library for Liquidity Amount\n/// @author Trader Joe\n/// @notice Periphery library to help compute liquidity amounts from amounts and ids.\n/// @dev The caller must ensure that the parameters are valid following the comments.\nlibrary LiquidityAmounts {\n    using Math512Bits for uint256;\n    using SafeCast for uint256;\n\n    /// @notice Return the liquidities amounts received for a given amount of tokenX and tokenY\n    /// @dev The caller needs to ensure that the ids are unique, if not, the result will be wrong.\n    /// @param ids the list of ids where the user want to add liquidity\n    /// @param binStep the binStep of the pair\n    /// @param amountX the amount of tokenX\n    /// @param amountY the amount of tokenY\n    /// @return liquidities the amounts of liquidity received\n    function getLiquiditiesForAmounts(\n        uint256[] memory ids,\n        uint16 binStep,\n        uint112 amountX,\n        uint112 amountY\n    ) internal pure returns (uint256[] memory liquidities) {\n        liquidities = new uint256[](ids.length);\n\n        for (uint256 i; i < ids.length; ++i) {\n            uint256 price = BinHelper.getPriceFromId(ids[i].safe24(), binStep);\n\n            liquidities[i] = price.mulShiftRoundDown(amountX, Constants.SCALE_OFFSET) + amountY;\n        }\n    }\n\n    /// @notice Return the amounts of token received for a given amount of liquidities\n    /// @dev The different arrays needs to use the same binId for each index\n    /// @param liquidities the list of liquidity amounts for each binId\n    /// @param totalSupplies the list of totalSupply for each binId\n    /// @param binReservesX the list of reserve of token X for each binId\n    /// @param binReservesY the list of reserve of token Y for each binId\n    /// @return amountX the amount of tokenX received by the user\n    /// @return amountY the amount of tokenY received by the user\n    function getAmountsForLiquidities(\n        uint256[] memory liquidities,\n        uint256[] memory totalSupplies,\n        uint112[] memory binReservesX,\n        uint112[] memory binReservesY\n    ) internal pure returns (uint256 amountX, uint256 amountY) {\n        if (\n            liquidities.length != totalSupplies.length &&\n            liquidities.length != binReservesX.length &&\n            liquidities.length != binReservesY.length\n        ) revert LiquidityAmounts__LengthMismatch();\n\n        for (uint256 i; i < liquidities.length; ++i) {\n            amountX += liquidities[i].mulDivRoundDown(binReservesX[i], totalSupplies[i]);\n            amountY += liquidities[i].mulDivRoundDown(binReservesY[i], totalSupplies[i]);\n        }\n    }\n\n    /// @notice Return the ids and liquidities of an user\n    /// @dev The caller needs to ensure that the ids are unique, if not, the result will be wrong.\n    /// @param user The address of the user\n    /// @param ids the list of ids where the user have liquidity\n    /// @param LBPair The address of the LBPair\n    /// @return liquidities the list of amount of liquidity of the user\n    function getLiquiditiesOf(\n        address user,\n        uint256[] memory ids,\n        address LBPair\n    ) internal view returns (uint256[] memory liquidities) {\n        liquidities = new uint256[](ids.length);\n\n        for (uint256 i; i < ids.length; ++i) {\n            liquidities[i] = ILBToken(LBPair).balanceOf(user, ids[i].safe24());\n        }\n    }\n\n    /// @notice Return the amounts received by an user if he were to burn all its liquidity\n    /// @dev The caller needs to ensure that the ids are unique, if not, the result will be wrong.\n    /// @param user The address of the user\n    /// @param ids the list of ids where the user would remove its liquidity, ids need to be in ascending order to assert uniqueness\n    /// @param LBPair The address of the LBPair\n    /// @return amountX the amount of tokenX received by the user\n    /// @return amountY the amount of tokenY received by the user\n    function getAmountsOf(\n        address user,\n        uint256[] memory ids,\n        address LBPair\n    ) internal view returns (uint256 amountX, uint256 amountY) {\n        for (uint256 i; i < ids.length; ++i) {\n            uint24 id = ids[i].safe24();\n\n            uint256 liquidity = ILBToken(LBPair).balanceOf(user, id);\n            (uint256 binReserveX, uint256 binReserveY) = ILBPair(LBPair).getBin(id);\n            uint256 totalSupply = ILBToken(LBPair).totalSupply(id);\n\n            amountX += liquidity.mulDivRoundDown(binReserveX, totalSupply);\n            amountY += liquidity.mulDivRoundDown(binReserveY, totalSupply);\n        }\n    }\n}"
    },
    "contracts/LB/interfaces/IJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\n/// @title Joe V1 Factory Interface\n/// @notice Interface to interact with Joe V1 Factory\ninterface IJoeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n}"
    },
    "contracts/LB/interfaces/ILBFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./ILBPair.sol\";\nimport \"./IPendingOwnable.sol\";\n\n/// @title Liquidity Book Factory Interface\n/// @author Trader Joe\n/// @notice Required interface of LBFactory contract\ninterface ILBFactory is IPendingOwnable {\n    /// @dev Structure to store the LBPair information, such as:\n    /// - binStep: The bin step of the LBPair\n    /// - LBPair: The address of the LBPair\n    /// - createdByOwner: Whether the pair was created by the owner of the factory\n    /// - ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\n    struct LBPairInformation {\n        uint16 binStep;\n        ILBPair LBPair;\n        bool createdByOwner;\n        bool ignoredForRouting;\n    }\n}"
    },
    "contracts/LB/interfaces/ILBFlashLoanCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Liquidity Book Flashloan Callback Interface\n/// @author Trader Joe\n/// @notice Required interface to interact with LB flash loans\ninterface ILBFlashLoanCallback {\n    function LBFlashLoanCallback(\n        address sender,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}"
    },
    "contracts/LB/interfaces/ILBPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../libraries/FeeHelper.sol\";\nimport \"./ILBFactory.sol\";\nimport \"./ILBFlashLoanCallback.sol\";\n\n/// @title Liquidity Book Pair Interface\n/// @author Trader Joe\n/// @notice Required interface of LBPair contract\ninterface ILBPair {\n    /// @dev Structure to store the reserves of bins:\n    /// - reserveX: The current reserve of tokenX of the bin\n    /// - reserveY: The current reserve of tokenY of the bin\n    struct Bin {\n        uint112 reserveX;\n        uint112 reserveY;\n        uint256 accTokenXPerShare;\n        uint256 accTokenYPerShare;\n    }\n\n    /// @dev Structure to store the information of the pair such as:\n    /// slot0:\n    /// - activeId: The current id used for swaps, this is also linked with the price\n    /// - reserveX: The sum of amounts of tokenX across all bins\n    /// slot1:\n    /// - reserveY: The sum of amounts of tokenY across all bins\n    /// - oracleSampleLifetime: The lifetime of an oracle sample\n    /// - oracleSize: The current size of the oracle, can be increase by users\n    /// - oracleActiveSize: The current active size of the oracle, composed only from non empty data sample\n    /// - oracleLastTimestamp: The current last timestamp at which a sample was added to the circular buffer\n    /// - oracleId: The current id of the oracle\n    /// slot2:\n    /// - feesX: The current amount of fees to distribute in tokenX (total, protocol)\n    /// slot3:\n    /// - feesY: The current amount of fees to distribute in tokenY (total, protocol)\n    struct PairInformation {\n        uint24 activeId;\n        uint136 reserveX;\n        uint136 reserveY;\n        uint16 oracleSampleLifetime;\n        uint16 oracleSize;\n        uint16 oracleActiveSize;\n        uint40 oracleLastTimestamp;\n        uint16 oracleId;\n        FeeHelper.FeesDistribution feesX;\n        FeeHelper.FeesDistribution feesY;\n    }\n\n    /// @dev Structure to store the debts of users\n    /// - debtX: The tokenX's debt\n    /// - debtY: The tokenY's debt\n    struct Debts {\n        uint256 debtX;\n        uint256 debtY;\n    }\n\n    /// @dev Structure to store fees:\n    /// - tokenX: The amount of fees of token X\n    /// - tokenY: The amount of fees of token Y\n    struct Fees {\n        uint128 tokenX;\n        uint128 tokenY;\n    }\n\n    /// @dev Structure to minting informations:\n    /// - amountXIn: The amount of token X sent\n    /// - amountYIn: The amount of token Y sent\n    /// - amountXAddedToPair: The amount of token X that have been actually added to the pair\n    /// - amountYAddedToPair: The amount of token Y that have been actually added to the pair\n    /// - activeFeeX: Fees X currently generated\n    /// - activeFeeY: Fees Y currently generated\n    /// - totalDistributionX: Total distribution of token X. Should be 1e18 (100%) or 0 (0%)\n    /// - totalDistributionY: Total distribution of token Y. Should be 1e18 (100%) or 0 (0%)\n    /// - id: Id of the current working bin when looping on the distribution array\n    /// - amountX: The amount of token X deposited in the current bin\n    /// - amountY: The amount of token Y deposited in the current bin\n    /// - distributionX: Distribution of token X for the current working bin\n    /// - distributionY: Distribution of token Y for the current working bin\n    struct MintInfo {\n        uint256 amountXIn;\n        uint256 amountYIn;\n        uint256 amountXAddedToPair;\n        uint256 amountYAddedToPair;\n        uint256 activeFeeX;\n        uint256 activeFeeY;\n        uint256 totalDistributionX;\n        uint256 totalDistributionY;\n        uint256 id;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 distributionX;\n        uint256 distributionY;\n    }\n\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        uint256 indexed id,\n        bool swapForY,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 volatilityAccumulated,\n        uint256 fees\n    );\n\n    event FlashLoan(\n        address indexed sender,\n        ILBFlashLoanCallback indexed receiver,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee\n    );\n\n    event CompositionFee(\n        address indexed sender,\n        address indexed recipient,\n        uint256 indexed id,\n        uint256 feesX,\n        uint256 feesY\n    );\n\n    event DepositedToBin(\n        address indexed sender,\n        address indexed recipient,\n        uint256 indexed id,\n        uint256 amountX,\n        uint256 amountY\n    );\n\n    event WithdrawnFromBin(\n        address indexed sender,\n        address indexed recipient,\n        uint256 indexed id,\n        uint256 amountX,\n        uint256 amountY\n    );\n\n    event FeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n\n    event ProtocolFeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n\n    event OracleSizeIncreased(uint256 previousSize, uint256 newSize);\n\n    function tokenX() external view returns (IERC20);\n\n    function tokenY() external view returns (IERC20);\n\n    function factory() external view returns (ILBFactory);\n\n    function getReservesAndId()\n        external\n        view\n        returns (\n            uint256 reserveX,\n            uint256 reserveY,\n            uint256 activeId\n        );\n\n    function getGlobalFees()\n        external\n        view\n        returns (\n            uint128 feesXTotal,\n            uint128 feesYTotal,\n            uint128 feesXProtocol,\n            uint128 feesYProtocol\n        );\n\n    function getOracleParameters()\n        external\n        view\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        );\n\n    function getOracleSampleFrom(uint256 timeDelta)\n        external\n        view\n        returns (\n            uint256 cumulativeId,\n            uint256 cumulativeAccumulator,\n            uint256 cumulativeBinCrossed\n        );\n\n    function feeParameters() external view returns (FeeHelper.FeeParameters memory);\n\n    function findFirstNonEmptyBinId(uint24 id_, bool sentTokenY) external view returns (uint24 id);\n\n    function getBin(uint24 id) external view returns (uint256 reserveX, uint256 reserveY);\n\n    function pendingFees(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 amountX, uint256 amountY);\n\n    function swap(bool sentTokenY, address to) external returns (uint256 amountXOut, uint256 amountYOut);\n\n    function flashLoan(\n        ILBFlashLoanCallback receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function mint(\n        uint256[] calldata ids,\n        uint256[] calldata distributionX,\n        uint256[] calldata distributionY,\n        address to\n    )\n        external\n        returns (\n            uint256 amountXAddedToPair,\n            uint256 amountYAddedToPair,\n            uint256[] memory liquidityMinted\n        );\n\n    function burn(\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        address to\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function increaseOracleLength(uint16 newSize) external;\n\n    function collectFees(address account, uint256[] calldata ids) external returns (uint256 amountX, uint256 amountY);\n\n    function collectProtocolFees() external returns (uint128 amountX, uint128 amountY);\n\n    function setFeesParameters(bytes32 packedFeeParameters) external;\n\n    function forceDecay() external;\n\n    function initialize(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint24 activeId,\n        uint16 sampleLifetime,\n        bytes32 packedFeeParameters\n    ) external;\n}"
    },
    "contracts/LB/interfaces/ILBRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IJoeFactory.sol\";\nimport \"./ILBPair.sol\";\nimport \"./ILBToken.sol\";\nimport \"./IWAVAX.sol\";\n\n/// @title Liquidity Book Router Interface\n/// @author Trader Joe\n/// @notice Required interface of LBRouter contract\ninterface ILBRouter {\n    /// @dev The liquidity parameters, such as:\n    /// - tokenX: The address of token X\n    /// - tokenY: The address of token Y\n    /// - binStep: The bin step of the pair\n    /// - amountX: The amount to send of token X\n    /// - amountY: The amount to send of token Y\n    /// - amountXMin: The min amount of token X added to liquidity\n    /// - amountYMin: The min amount of token Y added to liquidity\n    /// - activeIdDesired: The active id that user wants to add liquidity from\n    /// - idSlippage: The number of id that are allowed to slip\n    /// - deltaIds: The list of delta ids to add liquidity (`deltaId = activeId - desiredId`)\n    /// - distributionX: The distribution of tokenX with sum(distributionX) = 100e18 (100%) or 0 (0%)\n    /// - distributionY: The distribution of tokenY with sum(distributionY) = 100e18 (100%) or 0 (0%)\n    /// - to: The address of the recipient\n    /// - deadline: The deadline of the tx\n    struct LiquidityParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        uint256 binStep;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 amountXMin;\n        uint256 amountYMin;\n        uint256 activeIdDesired;\n        uint256 idSlippage;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        address to;\n        uint256 deadline;\n    }\n\n    function factory() external view returns (ILBFactory);\n\n    function oldFactory() external view returns (IJoeFactory);\n\n    function wavax() external view returns (IWAVAX);\n\n    function getIdFromPrice(ILBPair LBPair, uint256 price) external view returns (uint24);\n\n    function getPriceFromId(ILBPair LBPair, uint24 id) external view returns (uint256);\n\n    function getSwapIn(\n        ILBPair LBPair,\n        uint256 amountOut,\n        bool swapForY\n    ) external view returns (uint256 amountIn, uint256 feesIn);\n\n    function getSwapOut(\n        ILBPair LBPair,\n        uint256 amountIn,\n        bool swapForY\n    ) external view returns (uint256 amountOut, uint256 feesIn);\n\n    function createLBPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint24 activeId,\n        uint16 binStep\n    ) external returns (ILBPair pair);\n\n    function addLiquidity(LiquidityParameters calldata liquidityParameters)\n        external\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted);\n\n    function addLiquidityAVAX(LiquidityParameters calldata liquidityParameters)\n        external\n        payable\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted);\n\n    function removeLiquidity(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint256 amountXMin,\n        uint256 amountYMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function removeLiquidityAVAX(\n        IERC20 token,\n        uint16 binStep,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMinAVAX,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactAVAXForTokens(\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapAVAXForExactTokens(\n        uint256 amountOut,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amountsIn);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMinAVAX,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function sweep(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) external;\n\n    function sweepLBToken(\n        ILBToken _lbToken,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts\n    ) external;\n}"
    },
    "contracts/LB/interfaces/ILBStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ILBStrategy {\n    /// @notice The liquidity parameters, such as:\n    /// @param tokenX: The address of token X\n    /// @param tokenY: The address of token Y\n    /// @param pair: The address of the LB pair\n    /// @param binStep: BinStep as per LB Pair\n    /// @param deltaIds: the bins you want to add liquidity to. Each value is relative to the active bin ID\n    /// @param distributionX: The percentage of X you want to add to each bin in deltaIds\n    /// @param distributionY: The percentage of Y you want to add to each bin in deltaIds\n    /// @param idSlippage: The slippage tolerance in case active bin moves during time it takes to transact\n    struct StrategyParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        address pair;\n        uint16 binStep;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        uint256 idSlippage;\n    }\n\n    function deltaIds() external view returns (int256[] memory deltaIds);\n\n    function distributionX()\n        external\n        view\n        returns (uint256[] memory distributionX);\n\n    function distributionY()\n        external\n        view\n        returns (uint256[] memory distributionY);\n\n    function idSlippage() external view returns (uint256);\n\n    function vault() external view returns (address);\n\n    function lbPair() external view returns (address);\n\n    function setKeeper(address _keeper) external;\n\n    function keeper() external view returns (address);\n\n    function strategyPositionAtIndex(\n        uint256 _index\n    ) external view returns (uint256);\n\n    function strategyPositionNumber() external view returns (uint256);\n\n    function checkProposedBinLength(\n        int256[] memory proposedDeltas,\n        uint256 activeId\n    ) external view returns (uint256);\n\n    function addLiquidity(\n        uint256 amountX,\n        uint256 amountY,\n        uint256 amountXMin,\n        uint256 amountYMin\n    ) external returns (uint256[] memory liquidityMinted);\n\n    function binStep() external view returns (uint16);\n\n    function balanceOfLiquidities()\n        external\n        view\n        returns (uint256 totalLiquidityBalance);\n\n    function removeLiquidity(\n        uint256 denominator\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function tokenX() external view returns (IERC20);\n\n    function tokenY() external view returns (IERC20);\n\n    function harvest() external;\n\n    function harvest(\n        address callFeeRecipient\n    ) external returns (uint256 amountXReceived, uint256 amountYReceived);\n\n    function earn() external;\n\n    function retireStrat() external;\n\n    function panic() external;\n\n    function pause() external;\n\n    function unpause() external;\n\n    function paused() external view returns (bool);\n\n    function joeRouter() external view returns (address);\n\n    function binHasYLiquidity(\n        int256[] memory _deltaIds\n    ) external view returns (bool hasYLiquidity);\n\n    function binHasXLiquidity(\n        int256[] memory _deltaIds\n    ) external view returns (bool hasXLiquidity);\n\n    function beforeDeposit() external;\n\n    function rewardsAvailable()\n        external\n        view\n        returns (uint256 rewardsX, uint256 rewardsY);\n\n    function executeRebalance(\n        int256[] memory _deltaIds,\n        uint256[] memory _distributionX,\n        uint256[] memory _distributionY,\n        uint256 _idSlippage\n    ) external returns (uint256 liquidityAfter);\n\n    function executeRebalance()\n        external\n        returns (uint256 amountX, uint256 amountY);\n\n    function checkLengthsPerformRebalance() external;\n\n    function strategyActiveBins()\n        external\n        view\n        returns (uint256[] memory activeBins);\n\n    function getBalanceX() external view returns (uint256);\n\n    function getBalanceY() external view returns (uint256);\n}"
    },
    "contracts/LB/interfaces/ILBToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/// @title Liquidity Book Token Interface\n/// @author Trader Joe\n/// @notice Required interface of LBToken contract\ninterface ILBToken is IERC165 {\n    event TransferSingle(address indexed sender, address indexed from, address indexed to, uint256 id, uint256 amount);\n\n    event TransferBatch(\n        address indexed sender,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory batchBalances);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\n\n    function setApprovalForAll(address sender, bool approved) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata id,\n        uint256[] calldata amount\n    ) external;\n}"
    },
    "contracts/LB/interfaces/IPendingOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Liquidity Book Pending Ownable Interface\n/// @author Trader Joe\n/// @notice Required interface of Pending Ownable contract used for LBFactory\ninterface IPendingOwnable {\n    event PendingOwnerSet(address indexed pendingOwner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function setPendingOwner(address pendingOwner) external;\n\n    function revokePendingOwner() external;\n\n    function becomeOwner() external;\n\n    function renounceOwnership() external;\n}"
    },
    "contracts/LB/interfaces/IWAVAX.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title WAVAX Interface\n/// @notice Required interface of Wrapped AVAX contract\ninterface IWAVAX is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}"
    },
    "contracts/LB/interfaces/IWrappedNative.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IWrappedNative {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}"
    },
    "contracts/LB/LBErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./interfaces/ILBPair.sol\";\n\n/** LBRouter errors */\n\nerror LBRouter__SenderIsNotWAVAX();\nerror LBRouter__PairNotCreated(address tokenX, address tokenY, uint256 binStep);\nerror LBRouter__WrongAmounts(uint256 amount, uint256 reserve);\nerror LBRouter__SwapOverflows(uint256 id);\nerror LBRouter__BrokenSwapSafetyCheck();\nerror LBRouter__NotFactoryOwner();\nerror LBRouter__TooMuchTokensIn(uint256 excess);\nerror LBRouter__BinReserveOverflows(uint256 id);\nerror LBRouter__IdOverflows(int256 id);\nerror LBRouter__LengthsMismatch();\nerror LBRouter__WrongTokenOrder();\nerror LBRouter__IdSlippageCaught(uint256 activeIdDesired, uint256 idSlippage, uint256 activeId);\nerror LBRouter__AmountSlippageCaught(uint256 amountXMin, uint256 amountX, uint256 amountYMin, uint256 amountY);\nerror LBRouter__IdDesiredOverflows(uint256 idDesired, uint256 idSlippage);\nerror LBRouter__FailedToSendAVAX(address recipient, uint256 amount);\nerror LBRouter__DeadlineExceeded(uint256 deadline, uint256 currentTimestamp);\nerror LBRouter__AmountSlippageBPTooBig(uint256 amountSlippage);\nerror LBRouter__InsufficientAmountOut(uint256 amountOutMin, uint256 amountOut);\nerror LBRouter__MaxAmountInExceeded(uint256 amountInMax, uint256 amountIn);\nerror LBRouter__InvalidTokenPath(address wrongToken);\nerror LBRouter__InvalidVersion(uint256 version);\nerror LBRouter__WrongAvaxLiquidityParameters(\n    address tokenX,\n    address tokenY,\n    uint256 amountX,\n    uint256 amountY,\n    uint256 msgValue\n);\n\n/** LBToken errors */\n\nerror LBToken__SpenderNotApproved(address owner, address spender);\nerror LBToken__TransferFromOrToAddress0();\nerror LBToken__MintToAddress0();\nerror LBToken__BurnFromAddress0();\nerror LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\nerror LBToken__LengthMismatch(uint256 accountsLength, uint256 idsLength);\nerror LBToken__SelfApproval(address owner);\nerror LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\nerror LBToken__TransferToSelf();\n\n/** LBFactory errors */\n\nerror LBFactory__IdenticalAddresses(IERC20 token);\nerror LBFactory__QuoteAssetNotWhitelisted(IERC20 quoteAsset);\nerror LBFactory__QuoteAssetAlreadyWhitelisted(IERC20 quoteAsset);\nerror LBFactory__AddressZero();\nerror LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\nerror LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\nerror LBFactory__DecreasingPeriods(uint16 filterPeriod, uint16 decayPeriod);\nerror LBFactory__ReductionFactorOverflows(uint16 reductionFactor, uint256 max);\nerror LBFactory__VariableFeeControlOverflows(uint16 variableFeeControl, uint256 max);\nerror LBFactory__BaseFeesBelowMin(uint256 baseFees, uint256 minBaseFees);\nerror LBFactory__FeesAboveMax(uint256 fees, uint256 maxFees);\nerror LBFactory__FlashLoanFeeAboveMax(uint256 fees, uint256 maxFees);\nerror LBFactory__BinStepRequirementsBreached(uint256 lowerBound, uint16 binStep, uint256 higherBound);\nerror LBFactory__ProtocolShareOverflows(uint16 protocolShare, uint256 max);\nerror LBFactory__FunctionIsLockedForUsers(address user);\nerror LBFactory__FactoryLockIsAlreadyInTheSameState();\nerror LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\nerror LBFactory__BinStepHasNoPreset(uint256 binStep);\nerror LBFactory__SameFeeRecipient(address feeRecipient);\nerror LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\nerror LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\nerror LBFactory__SameImplementation(address LBPairImplementation);\nerror LBFactory__ImplementationNotSet();\n\n/** LBPair errors */\n\nerror LBPair__InsufficientAmounts();\nerror LBPair__AddressZero();\nerror LBPair__AddressZeroOrThis();\nerror LBPair__CompositionFactorFlawed(uint256 id);\nerror LBPair__InsufficientLiquidityMinted(uint256 id);\nerror LBPair__InsufficientLiquidityBurned(uint256 id);\nerror LBPair__WrongLengths();\nerror LBPair__OnlyStrictlyIncreasingId();\nerror LBPair__OnlyFactory();\nerror LBPair__DistributionsOverflow();\nerror LBPair__OnlyFeeRecipient(address feeRecipient, address sender);\nerror LBPair__OracleNotEnoughSample();\nerror LBPair__AlreadyInitialized();\nerror LBPair__OracleNewSizeTooSmall(uint256 newSize, uint256 oracleSize);\nerror LBPair__FlashLoanCallbackFailed();\nerror LBPair__FlashLoanInvalidBalance();\nerror LBPair__FlashLoanInvalidToken();\n\n/** BinHelper errors */\n\nerror BinHelper__BinStepOverflows(uint256 bp);\nerror BinHelper__IdOverflows();\n\n/** Math128x128 errors */\n\nerror Math128x128__PowerUnderflow(uint256 x, int256 y);\nerror Math128x128__LogUnderflow();\n\n/** Math512Bits errors */\n\nerror Math512Bits__MulDivOverflow(uint256 prod1, uint256 denominator);\nerror Math512Bits__ShiftDivOverflow(uint256 prod1, uint256 denominator);\nerror Math512Bits__MulShiftOverflow(uint256 prod1, uint256 offset);\nerror Math512Bits__OffsetOverflows(uint256 offset);\n\n/** Oracle errors */\n\nerror Oracle__AlreadyInitialized(uint256 _index);\nerror Oracle__LookUpTimestampTooOld(uint256 _minTimestamp, uint256 _lookUpTimestamp);\nerror Oracle__NotInitialized();\n\n/** PendingOwnable errors */\n\nerror PendingOwnable__NotOwner();\nerror PendingOwnable__NotPendingOwner();\nerror PendingOwnable__PendingOwnerAlreadySet();\nerror PendingOwnable__NoPendingOwner();\nerror PendingOwnable__AddressZero();\n\n/** ReentrancyGuardUpgradeable errors */\n\nerror ReentrancyGuardUpgradeable__ReentrantCall();\nerror ReentrancyGuardUpgradeable__AlreadyInitialized();\n\n/** SafeCast errors */\n\nerror SafeCast__Exceeds256Bits(uint256 x);\nerror SafeCast__Exceeds248Bits(uint256 x);\nerror SafeCast__Exceeds240Bits(uint256 x);\nerror SafeCast__Exceeds232Bits(uint256 x);\nerror SafeCast__Exceeds224Bits(uint256 x);\nerror SafeCast__Exceeds216Bits(uint256 x);\nerror SafeCast__Exceeds208Bits(uint256 x);\nerror SafeCast__Exceeds200Bits(uint256 x);\nerror SafeCast__Exceeds192Bits(uint256 x);\nerror SafeCast__Exceeds184Bits(uint256 x);\nerror SafeCast__Exceeds176Bits(uint256 x);\nerror SafeCast__Exceeds168Bits(uint256 x);\nerror SafeCast__Exceeds160Bits(uint256 x);\nerror SafeCast__Exceeds152Bits(uint256 x);\nerror SafeCast__Exceeds144Bits(uint256 x);\nerror SafeCast__Exceeds136Bits(uint256 x);\nerror SafeCast__Exceeds128Bits(uint256 x);\nerror SafeCast__Exceeds120Bits(uint256 x);\nerror SafeCast__Exceeds112Bits(uint256 x);\nerror SafeCast__Exceeds104Bits(uint256 x);\nerror SafeCast__Exceeds96Bits(uint256 x);\nerror SafeCast__Exceeds88Bits(uint256 x);\nerror SafeCast__Exceeds80Bits(uint256 x);\nerror SafeCast__Exceeds72Bits(uint256 x);\nerror SafeCast__Exceeds64Bits(uint256 x);\nerror SafeCast__Exceeds56Bits(uint256 x);\nerror SafeCast__Exceeds48Bits(uint256 x);\nerror SafeCast__Exceeds40Bits(uint256 x);\nerror SafeCast__Exceeds32Bits(uint256 x);\nerror SafeCast__Exceeds24Bits(uint256 x);\nerror SafeCast__Exceeds16Bits(uint256 x);\nerror SafeCast__Exceeds8Bits(uint256 x);\n\n/** TreeMath errors */\n\nerror TreeMath__ErrorDepthSearch();\n\n/** JoeLibrary errors */\n\nerror JoeLibrary__IdenticalAddresses();\nerror JoeLibrary__AddressZero();\nerror JoeLibrary__InsufficientAmount();\nerror JoeLibrary__InsufficientLiquidity();\n\n/** TokenHelper errors */\n\nerror TokenHelper__NonContract();\nerror TokenHelper__CallFailed();\nerror TokenHelper__TransferFailed();\n\n/** LBQuoter errors */\n\nerror LBQuoter_InvalidLength();"
    },
    "contracts/LB/libraries/BinHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../LBErrors.sol\";\nimport \"./Math128x128.sol\";\n\n/// @title Liquidity Book Bin Helper Library\n/// @author Trader Joe\n/// @notice Contract used to convert bin ID to price and back\nlibrary BinHelper {\n    using Math128x128 for uint256;\n\n    int256 private constant REAL_ID_SHIFT = 1 << 23;\n\n    /// @notice Returns the id corresponding to the given price\n    /// @dev The id may be inaccurate due to rounding issues, always trust getPriceFromId rather than\n    /// getIdFromPrice\n    /// @param _price The price of y per x as a 128.128-binary fixed-point number\n    /// @param _binStep The bin step\n    /// @return The id corresponding to this price\n    function getIdFromPrice(uint256 _price, uint256 _binStep) internal pure returns (uint24) {\n        unchecked {\n            uint256 _binStepValue = _getBPValue(_binStep);\n\n            // can't overflow as `2**23 + log2(price) < 2**23 + 2**128 < max(uint256)`\n            int256 _id = REAL_ID_SHIFT + _price.log2() / _binStepValue.log2();\n\n            if (_id < 0 || uint256(_id) > type(uint24).max) revert BinHelper__IdOverflows();\n            return uint24(uint256(_id));\n        }\n    }\n\n    /// @notice Returns the price corresponding to the given ID, as a 128.128-binary fixed-point number\n    /// @dev This is the trusted function to link id to price, the other way may be inaccurate\n    /// @param _id The id\n    /// @param _binStep The bin step\n    /// @return The price corresponding to this id, as a 128.128-binary fixed-point number\n    function getPriceFromId(uint256 _id, uint256 _binStep) internal pure returns (uint256) {\n        if (_id > uint256(type(uint24).max)) revert BinHelper__IdOverflows();\n        unchecked {\n            int256 _realId = int256(_id) - REAL_ID_SHIFT;\n\n            return _getBPValue(_binStep).power(_realId);\n        }\n    }\n\n    /// @notice Returns the (1 + bp) value as a 128.128-decimal fixed-point number\n    /// @param _binStep The bp value in [1; 100] (referring to 0.01% to 1%)\n    /// @return The (1+bp) value as a 128.128-decimal fixed-point number\n    function _getBPValue(uint256 _binStep) internal pure returns (uint256) {\n        if (_binStep == 0 || _binStep > Constants.BASIS_POINT_MAX) revert BinHelper__BinStepOverflows(_binStep);\n\n        unchecked {\n            // can't overflow as `max(result) = 2**128 + 10_000 << 128 / 10_000 < max(uint256)`\n            return Constants.SCALE + (_binStep << Constants.SCALE_OFFSET) / Constants.BASIS_POINT_MAX;\n        }\n    }\n}"
    },
    "contracts/LB/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Liquidity Book Bit Math Library\n/// @author Trader Joe\n/// @notice Helper contract used for bit calculations\nlibrary BitMath {\n    /// @notice Returns the closest non-zero bit of `integer` to the right (of left) of the `bit` bits that is not `bit`\n    /// @param _integer The integer as a uint256\n    /// @param _bit The bit index\n    /// @param _rightSide Whether we're searching in the right side of the tree (true) or the left side (false)\n    /// @return The index of the closest non-zero bit. If there is no closest bit, it returns max(uint256)\n    function closestBit(\n        uint256 _integer,\n        uint8 _bit,\n        bool _rightSide\n    ) internal pure returns (uint256) {\n        return _rightSide ? closestBitRight(_integer, _bit - 1) : closestBitLeft(_integer, _bit + 1);\n    }\n\n    /// @notice Returns the most (or least) significant bit of `_integer`\n    /// @param _integer The integer\n    /// @param _isMostSignificant Whether we want the most (true) or the least (false) significant bit\n    /// @return The index of the most (or least) significant bit\n    function significantBit(uint256 _integer, bool _isMostSignificant) internal pure returns (uint8) {\n        return _isMostSignificant ? mostSignificantBit(_integer) : leastSignificantBit(_integer);\n    }\n\n    /// @notice Returns the index of the closest bit on the right of x that is non null\n    /// @param x The value as a uint256\n    /// @param bit The index of the bit to start searching at\n    /// @return id The index of the closest non null bit on the right of x.\n    /// If there is no closest bit, it returns max(uint256)\n    function closestBitRight(uint256 x, uint8 bit) internal pure returns (uint256 id) {\n        unchecked {\n            uint256 _shift = 255 - bit;\n            x <<= _shift;\n\n            // can't overflow as it's non-zero and we shifted it by `_shift`\n            return (x == 0) ? type(uint256).max : mostSignificantBit(x) - _shift;\n        }\n    }\n\n    /// @notice Returns the index of the closest bit on the left of x that is non null\n    /// @param x The value as a uint256\n    /// @param bit The index of the bit to start searching at\n    /// @return id The index of the closest non null bit on the left of x.\n    /// If there is no closest bit, it returns max(uint256)\n    function closestBitLeft(uint256 x, uint8 bit) internal pure returns (uint256 id) {\n        unchecked {\n            x >>= bit;\n\n            return (x == 0) ? type(uint256).max : leastSignificantBit(x) + bit;\n        }\n    }\n\n    /// @notice Returns the index of the most significant bit of x\n    /// @param x The value as a uint256\n    /// @return msb The index of the most significant bit of x\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 msb) {\n        unchecked {\n            if (x >= 1 << 128) {\n                x >>= 128;\n                msb = 128;\n            }\n            if (x >= 1 << 64) {\n                x >>= 64;\n                msb += 64;\n            }\n            if (x >= 1 << 32) {\n                x >>= 32;\n                msb += 32;\n            }\n            if (x >= 1 << 16) {\n                x >>= 16;\n                msb += 16;\n            }\n            if (x >= 1 << 8) {\n                x >>= 8;\n                msb += 8;\n            }\n            if (x >= 1 << 4) {\n                x >>= 4;\n                msb += 4;\n            }\n            if (x >= 1 << 2) {\n                x >>= 2;\n                msb += 2;\n            }\n            if (x >= 1 << 1) {\n                msb += 1;\n            }\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of x\n    /// @param x The value as a uint256\n    /// @return lsb The index of the least significant bit of x\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 lsb) {\n        unchecked {\n            if (x << 128 != 0) {\n                x <<= 128;\n                lsb = 128;\n            }\n            if (x << 64 != 0) {\n                x <<= 64;\n                lsb += 64;\n            }\n            if (x << 32 != 0) {\n                x <<= 32;\n                lsb += 32;\n            }\n            if (x << 16 != 0) {\n                x <<= 16;\n                lsb += 16;\n            }\n            if (x << 8 != 0) {\n                x <<= 8;\n                lsb += 8;\n            }\n            if (x << 4 != 0) {\n                x <<= 4;\n                lsb += 4;\n            }\n            if (x << 2 != 0) {\n                x <<= 2;\n                lsb += 2;\n            }\n            if (x << 1 != 0) {\n                lsb += 1;\n            }\n\n            return 255 - lsb;\n        }\n    }\n}"
    },
    "contracts/LB/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Liquidity Book Constants Library\n/// @author Trader Joe\n/// @notice Set of constants for Liquidity Book contracts\nlibrary Constants {\n    uint256 internal constant SCALE_OFFSET = 128;\n    uint256 internal constant SCALE = 1 << SCALE_OFFSET;\n\n    uint256 internal constant PRECISION = 1e18;\n    uint256 internal constant BASIS_POINT_MAX = 10_000;\n\n    /// @dev The expected return after a successful flash loan\n    bytes32 internal constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n}"
    },
    "contracts/LB/libraries/FeeHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Constants.sol\";\nimport \"./SafeCast.sol\";\nimport \"./SafeMath.sol\";\n\n/// @title Liquidity Book Fee Helper Library\n/// @author Trader Joe\n/// @notice Helper contract used for fees calculation\nlibrary FeeHelper {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n\n    /// @dev Structure to store the protocol fees:\n    /// - binStep: The bin step\n    /// - baseFactor: The base factor\n    /// - filterPeriod: The filter period, where the fees stays constant\n    /// - decayPeriod: The decay period, where the fees are halved\n    /// - reductionFactor: The reduction factor, used to calculate the reduction of the accumulator\n    /// - variableFeeControl: The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// - protocolShare: The share of fees sent to protocol\n    /// - maxVolatilityAccumulated: The max value of volatility accumulated\n    /// - volatilityAccumulated: The value of volatility accumulated\n    /// - volatilityReference: The value of volatility reference\n    /// - indexRef: The index reference\n    /// - time: The last time the accumulator was called\n    struct FeeParameters {\n        // 144 lowest bits in slot\n        uint16 binStep;\n        uint16 baseFactor;\n        uint16 filterPeriod;\n        uint16 decayPeriod;\n        uint16 reductionFactor;\n        uint24 variableFeeControl;\n        uint16 protocolShare;\n        uint24 maxVolatilityAccumulated;\n        // 112 highest bits in slot\n        uint24 volatilityAccumulated;\n        uint24 volatilityReference;\n        uint24 indexRef;\n        uint40 time;\n    }\n\n    /// @dev Structure used during swaps to distributes the fees:\n    /// - total: The total amount of fees\n    /// - protocol: The amount of fees reserved for protocol\n    struct FeesDistribution {\n        uint128 total;\n        uint128 protocol;\n    }\n\n    /// @notice Update the value of the volatility accumulated\n    /// @param _fp The current fee parameters\n    /// @param _activeId The current active id\n    function updateVariableFeeParameters(FeeParameters memory _fp, uint256 _activeId) internal view {\n        uint256 _deltaT = block.timestamp - _fp.time;\n\n        if (_deltaT >= _fp.filterPeriod || _fp.time == 0) {\n            _fp.indexRef = uint24(_activeId);\n            if (_deltaT < _fp.decayPeriod) {\n                unchecked {\n                    // This can't overflow as `reductionFactor <= BASIS_POINT_MAX`\n                    _fp.volatilityReference = uint24(\n                        (uint256(_fp.reductionFactor) * _fp.volatilityAccumulated) / Constants.BASIS_POINT_MAX\n                    );\n                }\n            } else {\n                _fp.volatilityReference = 0;\n            }\n        }\n\n        _fp.time = (block.timestamp).safe40();\n\n        updateVolatilityAccumulated(_fp, _activeId);\n    }\n\n    /// @notice Update the volatility accumulated\n    /// @param _fp The fee parameter\n    /// @param _activeId The current active id\n    function updateVolatilityAccumulated(FeeParameters memory _fp, uint256 _activeId) internal pure {\n        uint256 volatilityAccumulated = (_activeId.absSub(_fp.indexRef) * Constants.BASIS_POINT_MAX) +\n            _fp.volatilityReference;\n        _fp.volatilityAccumulated = volatilityAccumulated > _fp.maxVolatilityAccumulated\n            ? _fp.maxVolatilityAccumulated\n            : uint24(volatilityAccumulated);\n    }\n\n    /// @notice Returns the base fee added to a swap, with 18 decimals\n    /// @param _fp The current fee parameters\n    /// @return The fee with 18 decimals precision\n    function getBaseFee(FeeParameters memory _fp) internal pure returns (uint256) {\n        unchecked {\n            return uint256(_fp.baseFactor) * _fp.binStep * 1e10;\n        }\n    }\n\n    /// @notice Returns the variable fee added to a swap, with 18 decimals\n    /// @param _fp The current fee parameters\n    /// @return variableFee The variable fee with 18 decimals precision\n    function getVariableFee(FeeParameters memory _fp) internal pure returns (uint256 variableFee) {\n        if (_fp.variableFeeControl != 0) {\n            // Can't overflow as the max value is `max(uint24) * (max(uint24) * max(uint16)) ** 2 < max(uint104)`\n            // It returns 18 decimals as:\n            // decimals(variableFeeControl * (volatilityAccumulated * binStep)**2 / 100) = 4 + (4 + 4) * 2 - 2 = 18\n            unchecked {\n                uint256 _prod = uint256(_fp.volatilityAccumulated) * _fp.binStep;\n                variableFee = (_prod * _prod * _fp.variableFeeControl + 99) / 100;\n            }\n        }\n    }\n\n    /// @notice Return the amount of fees from an amount\n    /// @dev Rounds amount up, follows `amount = amountWithFees - getFeeAmountFrom(fp, amountWithFees)`\n    /// @param _fp The current fee parameter\n    /// @param _amountWithFees The amount of token sent\n    /// @return The fee amount from the amount sent\n    function getFeeAmountFrom(FeeParameters memory _fp, uint256 _amountWithFees) internal pure returns (uint256) {\n        return (_amountWithFees * getTotalFee(_fp) + Constants.PRECISION - 1) / (Constants.PRECISION);\n    }\n\n    /// @notice Return the fees to add to an amount\n    /// @dev Rounds amount up, follows `amountWithFees = amount + getFeeAmount(fp, amount)`\n    /// @param _fp The current fee parameter\n    /// @param _amount The amount of token sent\n    /// @return The fee amount to add to the amount\n    function getFeeAmount(FeeParameters memory _fp, uint256 _amount) internal pure returns (uint256) {\n        uint256 _fee = getTotalFee(_fp);\n        uint256 _denominator = Constants.PRECISION - _fee;\n        return (_amount * _fee + _denominator - 1) / _denominator;\n    }\n\n    /// @notice Return the fees added when an user adds liquidity and change the ratio in the active bin\n    /// @dev Rounds amount up\n    /// @param _fp The current fee parameter\n    /// @param _amountWithFees The amount of token sent\n    /// @return The fee amount\n    function getFeeAmountForC(FeeParameters memory _fp, uint256 _amountWithFees) internal pure returns (uint256) {\n        uint256 _fee = getTotalFee(_fp);\n        uint256 _denominator = Constants.PRECISION * Constants.PRECISION;\n        return (_amountWithFees * _fee * (_fee + Constants.PRECISION) + _denominator - 1) / _denominator;\n    }\n\n    /// @notice Return the fees distribution added to an amount\n    /// @param _fp The current fee parameter\n    /// @param _fees The fee amount\n    /// @return fees The fee distribution\n    function getFeeAmountDistribution(FeeParameters memory _fp, uint256 _fees)\n        internal\n        pure\n        returns (FeesDistribution memory fees)\n    {\n        fees.total = _fees.safe128();\n        // unsafe math is fine because total >= protocol\n        unchecked {\n            fees.protocol = uint128((_fees * _fp.protocolShare) / Constants.BASIS_POINT_MAX);\n        }\n    }\n\n    /// @notice Return the total fee, i.e. baseFee + variableFee\n    /// @param _fp The current fee parameter\n    /// @return The total fee, with 18 decimals\n    function getTotalFee(FeeParameters memory _fp) private pure returns (uint256) {\n        unchecked {\n            return getBaseFee(_fp) + getVariableFee(_fp);\n        }\n    }\n}"
    },
    "contracts/LB/libraries/Math128x128.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../LBErrors.sol\";\nimport \"./BitMath.sol\";\nimport \"./Constants.sol\";\nimport \"./Math512Bits.sol\";\n\n/// @title Liquidity Book Math Helper Library\n/// @author Trader Joe\n/// @notice Helper contract used for power and log calculations\nlibrary Math128x128 {\n    using Math512Bits for uint256;\n    using BitMath for uint256;\n\n    uint256 constant LOG_SCALE_OFFSET = 127;\n    uint256 constant LOG_SCALE = 1 << LOG_SCALE_OFFSET;\n    uint256 constant LOG_SCALE_SQUARED = LOG_SCALE * LOG_SCALE;\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than zero.\n    ///\n    /// Caveats:\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation\n    /// Also because x is converted to an unsigned 129.127-binary fixed-point number during the operation to optimize the multiplication\n    ///\n    /// @param x The unsigned 128.128-binary fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as a signed 128.128-binary fixed-point number.\n    function log2(uint256 x) internal pure returns (int256 result) {\n        // Convert x to a unsigned 129.127-binary fixed-point number to optimize the multiplication.\n        // If we use an offset of 128 bits, y would need 129 bits and y**2 would would overflow and we would have to\n        // use mulDiv, by reducing x to 129.127-binary fixed-point number we assert that y will use 128 bits, and we\n        // can use the regular multiplication\n\n        if (x == 1) return -128;\n        if (x == 0) revert Math128x128__LogUnderflow();\n\n        x >>= 1;\n\n        unchecked {\n            // This works because log2(x) = -log2(1/x).\n            int256 sign;\n            if (x >= LOG_SCALE) {\n                sign = 1;\n            } else {\n                sign = -1;\n                // Do the fixed-point inversion inline to save gas\n                x = LOG_SCALE_SQUARED / x;\n            }\n\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = (x >> LOG_SCALE_OFFSET).mostSignificantBit();\n\n            // The integer part of the logarithm as a signed 129.127-binary fixed-point number. The operation can't overflow\n            // because n is maximum 255, LOG_SCALE_OFFSET is 127 bits and sign is either 1 or -1.\n            result = int256(n) << LOG_SCALE_OFFSET;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y != LOG_SCALE) {\n                // Calculate the fractional part via the iterative approximation.\n                // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n                for (int256 delta = int256(1 << (LOG_SCALE_OFFSET - 1)); delta > 0; delta >>= 1) {\n                    y = (y * y) >> LOG_SCALE_OFFSET;\n\n                    // Is y^2 > 2 and so in the range [2,4)?\n                    if (y >= 1 << (LOG_SCALE_OFFSET + 1)) {\n                        // Add the 2^(-m) factor to the logarithm.\n                        result += delta;\n\n                        // Corresponds to z/2 on Wikipedia.\n                        y >>= 1;\n                    }\n                }\n            }\n            // Convert x back to unsigned 128.128-binary fixed-point number\n            result = (result * sign) << 1;\n        }\n    }\n\n    /// @notice Returns the value of x^y. It calculates `1 / x^abs(y)` if x is bigger than 2^128.\n    /// At the end of the operations, we invert the result if needed.\n    /// @param x The unsigned 128.128-binary fixed-point number for which to calculate the power\n    /// @param y A relative number without any decimals, needs to be between ]2^20; 2^20[\n    /// @return result The result of `x^y`\n    function power(uint256 x, int256 y) internal pure returns (uint256 result) {\n        bool invert;\n        uint256 absY;\n\n        if (y == 0) return Constants.SCALE;\n\n        assembly {\n            absY := y\n            if slt(absY, 0) {\n                absY := sub(0, absY)\n                invert := iszero(invert)\n            }\n        }\n\n        if (absY < 0x100000) {\n            result = Constants.SCALE;\n            assembly {\n                let pow := x\n                if gt(x, 0xffffffffffffffffffffffffffffffff) {\n                    pow := div(not(0), pow)\n                    invert := iszero(invert)\n                }\n\n                if and(absY, 0x1) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x2) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x4) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x8) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x10) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x20) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x40) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x80) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x100) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x200) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x400) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x800) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x1000) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x2000) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x4000) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x8000) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x10000) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x20000) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x40000) {\n                    result := shr(128, mul(result, pow))\n                }\n                pow := shr(128, mul(pow, pow))\n                if and(absY, 0x80000) {\n                    result := shr(128, mul(result, pow))\n                }\n            }\n        }\n\n        // revert if y is too big or if x^y underflowed\n        if (result == 0) revert Math128x128__PowerUnderflow(x, y);\n\n        return invert ? type(uint256).max / result : result;\n    }\n}"
    },
    "contracts/LB/libraries/Math512Bits.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../LBErrors.sol\";\nimport \"./BitMath.sol\";\n\n/// @title Liquidity Book Math Helper Library\n/// @author Trader Joe\n/// @notice Helper contract used for full precision calculations\nlibrary Math512Bits {\n    using BitMath for uint256;\n\n    /// @notice Calculates floor(x*ydenominator) with full precision\n    /// The result will be rounded down\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero\n    /// - The result must fit within uint256\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers\n    ///\n    /// @param x The multiplicand as an uint256\n    /// @param y The multiplier as an uint256\n    /// @param denominator The divisor as an uint256\n    /// @return result The result as an uint256\n    function mulDivRoundDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        return _getEndOfDivRoundDown(x, y, denominator, prod0, prod1);\n    }\n\n    /// @notice Calculates x * y >> offset with full precision\n    /// The result will be rounded down\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    ///\n    /// Requirements:\n    /// - The offset needs to be strictly lower than 256\n    /// - The result must fit within uint256\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers\n    ///\n    /// @param x The multiplicand as an uint256\n    /// @param y The multiplier as an uint256\n    /// @param offset The offset as an uint256, can't be greater than 256\n    /// @return result The result as an uint256\n    function mulShiftRoundDown(\n        uint256 x,\n        uint256 y,\n        uint256 offset\n    ) internal pure returns (uint256 result) {\n        if (offset > 255) revert Math512Bits__OffsetOverflows(offset);\n\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        if (prod0 != 0) result = prod0 >> offset;\n        if (prod1 != 0) {\n            // Make sure the result is less than 2^256.\n            if (prod1 >= 1 << offset) revert Math512Bits__MulShiftOverflow(prod1, offset);\n\n            unchecked {\n                result += prod1 << (256 - offset);\n            }\n        }\n    }\n\n    /// @notice Calculates x * y >> offset with full precision\n    /// The result will be rounded up\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    ///\n    /// Requirements:\n    /// - The offset needs to be strictly lower than 256\n    /// - The result must fit within uint256\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers\n    ///\n    /// @param x The multiplicand as an uint256\n    /// @param y The multiplier as an uint256\n    /// @param offset The offset as an uint256, can't be greater than 256\n    /// @return result The result as an uint256\n    function mulShiftRoundUp(\n        uint256 x,\n        uint256 y,\n        uint256 offset\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulShiftRoundDown(x, y, offset);\n            if (mulmod(x, y, 1 << offset) != 0) result += 1;\n        }\n    }\n\n    /// @notice Calculates x << offset / y with full precision\n    /// The result will be rounded down\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    ///\n    /// Requirements:\n    /// - The offset needs to be strictly lower than 256\n    /// - The result must fit within uint256\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers\n    ///\n    /// @param x The multiplicand as an uint256\n    /// @param offset The number of bit to shift x as an uint256\n    /// @param denominator The divisor as an uint256\n    /// @return result The result as an uint256\n    function shiftDivRoundDown(\n        uint256 x,\n        uint256 offset,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        if (offset > 255) revert Math512Bits__OffsetOverflows(offset);\n        uint256 prod0;\n        uint256 prod1;\n\n        prod0 = x << offset; // Least significant 256 bits of the product\n        unchecked {\n            prod1 = x >> (256 - offset); // Most significant 256 bits of the product\n        }\n\n        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);\n    }\n\n    /// @notice Calculates x << offset / y with full precision\n    /// The result will be rounded up\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    ///\n    /// Requirements:\n    /// - The offset needs to be strictly lower than 256\n    /// - The result must fit within uint256\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers\n    ///\n    /// @param x The multiplicand as an uint256\n    /// @param offset The number of bit to shift x as an uint256\n    /// @param denominator The divisor as an uint256\n    /// @return result The result as an uint256\n    function shiftDivRoundUp(\n        uint256 x,\n        uint256 offset,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = shiftDivRoundDown(x, offset, denominator);\n        unchecked {\n            if (mulmod(x, 1 << offset, denominator) != 0) result += 1;\n        }\n    }\n\n    /// @notice Helper function to return the result of `x * y` as 2 uint256\n    /// @param x The multiplicand as an uint256\n    /// @param y The multiplier as an uint256\n    /// @return prod0 The least significant 256 bits of the product\n    /// @return prod1 The most significant 256 bits of the product\n    function _getMulProds(uint256 x, uint256 y) private pure returns (uint256 prod0, uint256 prod1) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n    }\n\n    /// @notice Helper function to return the result of `x * y / denominator` with full precision\n    /// @param x The multiplicand as an uint256\n    /// @param y The multiplier as an uint256\n    /// @param denominator The divisor as an uint256\n    /// @param prod0 The least significant 256 bits of the product\n    /// @param prod1 The most significant 256 bits of the product\n    /// @return result The result as an uint256\n    function _getEndOfDivRoundDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        uint256 prod0,\n        uint256 prod1\n    ) private pure returns (uint256 result) {\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n        } else {\n            // Make sure the result is less than 2^256. Also prevents denominator == 0\n            if (prod1 >= denominator) revert Math512Bits__MulDivOverflow(prod1, denominator);\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1\n            // See https://cs.stackexchange.com/q/138556/92363\n            unchecked {\n                // Does not overflow because the denominator cannot be zero at this stage in the function\n                uint256 lpotdod = denominator & (~denominator + 1);\n                assembly {\n                    // Divide denominator by lpotdod.\n                    denominator := div(denominator, lpotdod)\n\n                    // Divide [prod1 prod0] by lpotdod.\n                    prod0 := div(prod0, lpotdod)\n\n                    // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one\n                    lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n                }\n\n                // Shift in bits from prod1 into prod0\n                prod0 |= prod1 * lpotdod;\n\n                // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n                // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n                // four bits. That is, denominator * inv = 1 mod 2^4\n                uint256 inverse = (3 * denominator) ^ 2;\n\n                // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n                // in modular arithmetic, doubling the correct bits in each step\n                inverse *= 2 - denominator * inverse; // inverse mod 2^8\n                inverse *= 2 - denominator * inverse; // inverse mod 2^16\n                inverse *= 2 - denominator * inverse; // inverse mod 2^32\n                inverse *= 2 - denominator * inverse; // inverse mod 2^64\n                inverse *= 2 - denominator * inverse; // inverse mod 2^128\n                inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n                // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n                // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n                // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n                // is no longer required.\n                result = prod0 * inverse;\n            }\n        }\n    }\n}"
    },
    "contracts/LB/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../LBErrors.sol\";\n\n/// @title Liquidity Book Safe Cast Library\n/// @author Trader Joe\n/// @notice Helper contract used for converting uint values safely\nlibrary SafeCast {\n    /// @notice Returns x on uint248 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint248\n    function safe248(uint256 x) internal pure returns (uint248 y) {\n        if ((y = uint248(x)) != x) revert SafeCast__Exceeds248Bits(x);\n    }\n\n    /// @notice Returns x on uint240 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint240\n    function safe240(uint256 x) internal pure returns (uint240 y) {\n        if ((y = uint240(x)) != x) revert SafeCast__Exceeds240Bits(x);\n    }\n\n    /// @notice Returns x on uint232 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint232\n    function safe232(uint256 x) internal pure returns (uint232 y) {\n        if ((y = uint232(x)) != x) revert SafeCast__Exceeds232Bits(x);\n    }\n\n    /// @notice Returns x on uint224 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint224\n    function safe224(uint256 x) internal pure returns (uint224 y) {\n        if ((y = uint224(x)) != x) revert SafeCast__Exceeds224Bits(x);\n    }\n\n    /// @notice Returns x on uint216 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint216\n    function safe216(uint256 x) internal pure returns (uint216 y) {\n        if ((y = uint216(x)) != x) revert SafeCast__Exceeds216Bits(x);\n    }\n\n    /// @notice Returns x on uint208 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint208\n    function safe208(uint256 x) internal pure returns (uint208 y) {\n        if ((y = uint208(x)) != x) revert SafeCast__Exceeds208Bits(x);\n    }\n\n    /// @notice Returns x on uint200 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint200\n    function safe200(uint256 x) internal pure returns (uint200 y) {\n        if ((y = uint200(x)) != x) revert SafeCast__Exceeds200Bits(x);\n    }\n\n    /// @notice Returns x on uint192 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint192\n    function safe192(uint256 x) internal pure returns (uint192 y) {\n        if ((y = uint192(x)) != x) revert SafeCast__Exceeds192Bits(x);\n    }\n\n    /// @notice Returns x on uint184 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint184\n    function safe184(uint256 x) internal pure returns (uint184 y) {\n        if ((y = uint184(x)) != x) revert SafeCast__Exceeds184Bits(x);\n    }\n\n    /// @notice Returns x on uint176 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint176\n    function safe176(uint256 x) internal pure returns (uint176 y) {\n        if ((y = uint176(x)) != x) revert SafeCast__Exceeds176Bits(x);\n    }\n\n    /// @notice Returns x on uint168 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint168\n    function safe168(uint256 x) internal pure returns (uint168 y) {\n        if ((y = uint168(x)) != x) revert SafeCast__Exceeds168Bits(x);\n    }\n\n    /// @notice Returns x on uint160 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint160\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        if ((y = uint160(x)) != x) revert SafeCast__Exceeds160Bits(x);\n    }\n\n    /// @notice Returns x on uint152 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint152\n    function safe152(uint256 x) internal pure returns (uint152 y) {\n        if ((y = uint152(x)) != x) revert SafeCast__Exceeds152Bits(x);\n    }\n\n    /// @notice Returns x on uint144 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint144\n    function safe144(uint256 x) internal pure returns (uint144 y) {\n        if ((y = uint144(x)) != x) revert SafeCast__Exceeds144Bits(x);\n    }\n\n    /// @notice Returns x on uint136 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint136\n    function safe136(uint256 x) internal pure returns (uint136 y) {\n        if ((y = uint136(x)) != x) revert SafeCast__Exceeds136Bits(x);\n    }\n\n    /// @notice Returns x on uint128 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint128\n    function safe128(uint256 x) internal pure returns (uint128 y) {\n        if ((y = uint128(x)) != x) revert SafeCast__Exceeds128Bits(x);\n    }\n\n    /// @notice Returns x on uint120 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint120\n    function safe120(uint256 x) internal pure returns (uint120 y) {\n        if ((y = uint120(x)) != x) revert SafeCast__Exceeds120Bits(x);\n    }\n\n    /// @notice Returns x on uint112 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint112\n    function safe112(uint256 x) internal pure returns (uint112 y) {\n        if ((y = uint112(x)) != x) revert SafeCast__Exceeds112Bits(x);\n    }\n\n    /// @notice Returns x on uint104 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint104\n    function safe104(uint256 x) internal pure returns (uint104 y) {\n        if ((y = uint104(x)) != x) revert SafeCast__Exceeds104Bits(x);\n    }\n\n    /// @notice Returns x on uint96 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint96\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        if ((y = uint96(x)) != x) revert SafeCast__Exceeds96Bits(x);\n    }\n\n    /// @notice Returns x on uint88 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint88\n    function safe88(uint256 x) internal pure returns (uint88 y) {\n        if ((y = uint88(x)) != x) revert SafeCast__Exceeds88Bits(x);\n    }\n\n    /// @notice Returns x on uint80 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint80\n    function safe80(uint256 x) internal pure returns (uint80 y) {\n        if ((y = uint80(x)) != x) revert SafeCast__Exceeds80Bits(x);\n    }\n\n    /// @notice Returns x on uint72 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint72\n    function safe72(uint256 x) internal pure returns (uint72 y) {\n        if ((y = uint72(x)) != x) revert SafeCast__Exceeds72Bits(x);\n    }\n\n    /// @notice Returns x on uint64 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint64\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        if ((y = uint64(x)) != x) revert SafeCast__Exceeds64Bits(x);\n    }\n\n    /// @notice Returns x on uint56 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint56\n    function safe56(uint256 x) internal pure returns (uint56 y) {\n        if ((y = uint56(x)) != x) revert SafeCast__Exceeds56Bits(x);\n    }\n\n    /// @notice Returns x on uint48 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint48\n    function safe48(uint256 x) internal pure returns (uint48 y) {\n        if ((y = uint48(x)) != x) revert SafeCast__Exceeds48Bits(x);\n    }\n\n    /// @notice Returns x on uint40 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint40\n    function safe40(uint256 x) internal pure returns (uint40 y) {\n        if ((y = uint40(x)) != x) revert SafeCast__Exceeds40Bits(x);\n    }\n\n    /// @notice Returns x on uint32 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint32\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        if ((y = uint32(x)) != x) revert SafeCast__Exceeds32Bits(x);\n    }\n\n    /// @notice Returns x on uint24 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint24\n    function safe24(uint256 x) internal pure returns (uint24 y) {\n        if ((y = uint24(x)) != x) revert SafeCast__Exceeds24Bits(x);\n    }\n\n    /// @notice Returns x on uint16 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint16\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        if ((y = uint16(x)) != x) revert SafeCast__Exceeds16Bits(x);\n    }\n\n    /// @notice Returns x on uint8 and check that it does not overflow\n    /// @param x The value as an uint256\n    /// @return y The value as an uint8\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        if ((y = uint8(x)) != x) revert SafeCast__Exceeds8Bits(x);\n    }\n}"
    },
    "contracts/LB/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Liquidity Book Safe Math Helper Library\n/// @author Trader Joe\n/// @notice Helper contract used for calculating absolute value safely\nlibrary SafeMath {\n    /// @notice absSub, can't underflow or overflow\n    /// @param x The first value\n    /// @param y The second value\n    /// @return The result of abs(x - y)\n    function absSub(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            return x > y ? x - y : y - x;\n        }\n    }\n}"
    },
    "contracts/strategy/LBStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\nimport '../common/StratManager.sol';\nimport '../interfaces/ILBStrategy.sol';\n\nimport '../LB/interfaces/ILBToken.sol';\nimport '../LB/interfaces/ILBPair.sol';\nimport '../LB/interfaces/ILBRouter.sol';\nimport '../LB-periph/LiquidityAmounts.sol';\n\n/// @notice used in conjunction with a vault to manage TraderJoe Liquidity Book Positions\ncontract StrategyTJLiquidityBookLB is StratManager {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    uint256 constant PRECISION = 1e18;\n\n    uint256 public lastHarvest;\n\n    /// @notice parameters which should not be changed after init\n    IERC20 public immutable tokenX;\n    IERC20 public immutable tokenY;\n    ILBPair public immutable lbPair;\n    ILBToken public immutable lbToken;\n    uint16 public immutable binStep;\n\n    /// @notice parameters which may be changed by a strategist\n    int256[] public deltaIds;\n    uint256[] public distributionX;\n    uint256[] public distributionY;\n    uint256 public idSlippage;\n\n    /// @notice where strategy currently has a non-zero balance in bins\n    EnumerableSet.UintSet private _activeBins;\n\n    /// -----------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------\n    event CollectRewards(\n        uint256 lastHarvest,\n        uint256 amountXBefore,\n        uint256 amountYBefore,\n        uint256 amountXAfter,\n        uint256 amountYAfter\n    );\n\n    event FeeTransfer(uint256 amountX, uint256 amountY);\n\n    event AddLiquidity(\n        address user,\n        uint256 amountX,\n        uint256 amountY,\n        uint256 liquidity\n    );\n\n    event RemoveLiquidity(address user, uint256 amountX, uint256 amountY);\n\n    event Rebalance(\n        uint256 amountXBefore,\n        uint256 amountYBefore,\n        uint256 amountXAfter,\n        uint256 amountYAfter\n    );\n\n    /// -----------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------\n\n    constructor(\n        address _joeRouter,\n        address _keeper,\n        address _vault,\n        ILBStrategy.StrategyParameters memory _strategyParams\n    ) StratManager(_keeper, _joeRouter, _vault) {\n        //require strategy to use < 50 bins due to gas limits\n        require(\n            _strategyParams.deltaIds.length < 50,\n            'Strategy: Too many bins'\n        );\n\n        //check parameters are equal in length\n        require(\n            _strategyParams.deltaIds.length ==\n                _strategyParams.distributionX.length &&\n                _strategyParams.distributionX.length ==\n                _strategyParams.distributionY.length,\n            'Strategy: Unbalanced params'\n        );\n\n        //check distributions are equal\n        if (binHasXLiquidity(_strategyParams.deltaIds)) {\n            _checkDistribution(_strategyParams.distributionX);\n        }\n        if (binHasYLiquidity(_strategyParams.deltaIds)) {\n            _checkDistribution(_strategyParams.distributionY);\n        }\n\n        //set immutable strategy parameters\n        tokenX = _strategyParams.tokenX;\n        tokenY = _strategyParams.tokenY;\n        lbPair = ILBPair(_strategyParams.pair);\n        lbToken = ILBToken(_strategyParams.pair);\n        binStep = _strategyParams.binStep;\n\n        //set strategist controlled initial parameters\n        deltaIds = _strategyParams.deltaIds;\n        idSlippage = _strategyParams.idSlippage;\n        distributionX = _strategyParams.distributionX;\n        distributionY = _strategyParams.distributionY;\n\n        //give the strategy the required allowances\n        _giveAllowances();\n    }\n\n    /// -----------------------------------------------------------\n    /// Track Strategy Bin Functions\n    /// -----------------------------------------------------------\n\n    /// @notice Returns the type id at index `_index` where strategy has a non-zero balance\n    /// @param _index The position index\n    /// @return The non-zero position at index `_index`\n    function strategyPositionAtIndex(\n        uint256 _index\n    ) public view returns (uint256) {\n        return _activeBins.at(_index);\n    }\n\n    /// @notice Returns the number of non-zero balances of strategy\n    /// @return The number of non-zero balances of strategy\n    function strategyPositionNumber() public view returns (uint256) {\n        return _activeBins.length();\n    }\n\n    /// @notice returns all of the active bin Ids in the strategy\n    /// @return activeBins currently in use by the strategy\n    function strategyActiveBins()\n        public\n        view\n        returns (uint256[] memory activeBins)\n    {\n        activeBins = new uint256[](_activeBins.length());\n        for (uint256 i; i < _activeBins.length(); i++) {\n            activeBins[i] = strategyPositionAtIndex(i);\n        }\n    }\n\n    /// @notice checks the proposed bin length\n    /// @notice helps to ensure that we wont exceed the 50 bin limit in single call\n    /// @return numProposedIds number of proposed bin Ids\n    function checkProposedBinLength(\n        int256[] memory proposedDeltas,\n        uint256 activeId\n    ) public view returns (uint256) {\n        uint256 newIdCount;\n        for (uint256 i; i < proposedDeltas.length; i++) {\n            int256 _id = int256(activeId) + proposedDeltas[i];\n\n            //if the proposed ID doesnt exist count it\n            if (!_activeBins.contains(uint256(_id))) {\n                newIdCount += 1;\n            }\n        }\n        return (newIdCount + strategyPositionNumber());\n    }\n\n    /// -----------------------------------------------------------\n    /// Internal functions\n    /// -----------------------------------------------------------\n\n    /// Internal function that adds liquidity to AMM and gets Liquidity Book tokens.\n    /// @param amountX max amount of token X to add as liquidity\n    /// @param amountY max amount of token Y to add as liquidity\n    /// @param amountXMin min amount of token X to add as liquidity\n    /// @param amountYMin min amount of token Y to add as liquidity\n    /// @return depositIds the depositIds where liquidity was minted\n    /// @return liquidityMinted set of liquidity deposited in each bin\n    function _addLiquidity(\n        uint256 amountX,\n        uint256 amountY,\n        uint256 amountXMin,\n        uint256 amountYMin\n    )\n        internal\n        whenNotPaused\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        //fetch the current active Id.\n        (, , uint256 activeId) = lbPair.getReservesAndId();\n\n        //check bin lengths are less than 50 bins due to block limit\n        //further liquidity cannot be added until rebalanced\n        require(\n            checkProposedBinLength(deltaIds, activeId) < 50,\n            'Strategy: Requires Rebalance'\n        );\n\n        //set the required liquidity parameters\n        ILBRouter.LiquidityParameters memory liquidityParameters = ILBRouter\n            .LiquidityParameters(\n                tokenX,\n                tokenY,\n                binStep,\n                amountX,\n                amountY,\n                amountXMin,\n                amountYMin,\n                activeId,\n                idSlippage,\n                deltaIds,\n                distributionX,\n                distributionY,\n                address(this),\n                block.timestamp\n            );\n\n        //add the required liquidity into the pair\n        (depositIds, liquidityMinted) = ILBRouter(joeRouter).addLiquidity(\n            liquidityParameters\n        );\n\n        //sum the total amount of liquidity minted\n        uint256 liquidtyMintedHolder;\n        for (uint256 i; i < liquidityMinted.length; i++) {\n            liquidtyMintedHolder += liquidityMinted[i];\n            //add the ID's to the user set\n            _activeBins.add(depositIds[i]);\n        }\n\n        require(\n            _activeBins.length() < 50,\n            'Strategy: Too many bins after add; manager check bin slippage and call rebalance'\n        );\n\n        //emit an event\n        emit AddLiquidity(msg.sender, amountX, amountY, liquidtyMintedHolder);\n    }\n\n    /// @notice performs the removal of liquidity from the pair and keeps tokens in strategy\n    /// @param denominator the ownership stake to remove\n    /// @notice PRECISION is full amount i.e all liquidity to be removed\n    /// @return amountX the amount of liquidity removed as tokenX\n    /// @return amountY the amount of liquidity removed as tokenY\n    function _removeLiquidity(\n        uint256 denominator\n    ) internal returns (uint256 amountX, uint256 amountY) {\n        uint256[] memory activeBinIds = getActiveBinIds();\n        uint256[] memory amounts = new uint256[](activeBinIds.length);\n\n        uint256 totalXBalanceWithdrawn;\n        uint256 totalYBalanceWithdrawn;\n\n        // To figure out amountXMin and amountYMin, we calculate how much X and Y underlying we have as liquidity\n        for (uint256 i; i < activeBinIds.length; i++) {\n            //amount of LBToken in each active bin\n            uint256 LBTokenAmount = (PRECISION *\n                lbToken.balanceOf(address(this), activeBinIds[i])) /\n                (denominator);\n\n            amounts[i] = LBTokenAmount;\n            (uint256 binReserveX, uint256 binReserveY) = lbPair.getBin(\n                uint24(activeBinIds[i])\n            );\n\n            totalXBalanceWithdrawn +=\n                (LBTokenAmount * binReserveX) /\n                lbToken.totalSupply(activeBinIds[i]);\n            totalYBalanceWithdrawn +=\n                (LBTokenAmount * binReserveY) /\n                lbToken.totalSupply(activeBinIds[i]);\n        }\n\n        //remove the liquidity required\n        (amountX, amountY) = ILBRouter(payable(joeRouter)).removeLiquidity(\n            tokenX,\n            tokenY,\n            binStep,\n            0,\n            0,\n            activeBinIds,\n            amounts,\n            address(this),\n            block.timestamp\n        );\n\n        //remove the ids from the userSet; this needs to occur if we are withdrawing all liquidity\n        //or if we are rebalancing not each time liquidity is withdrawn\n        if (denominator == PRECISION) {\n            for (uint256 i; i < activeBinIds.length; i++) {\n                _activeBins.remove(activeBinIds[i]);\n            }\n        }\n\n        //emit event\n        emit RemoveLiquidity(msg.sender, amountX, amountY);\n    }\n\n    /// @notice gives the allowances required for this strategy\n    function _giveAllowances() internal {\n        uint256 MAX_INT = 2 ** 256 - 1;\n\n        tokenX.safeApprove(joeRouter, uint256(MAX_INT));\n        tokenY.safeApprove(joeRouter, uint256(MAX_INT));\n\n        tokenX.safeApprove(vault, uint256(MAX_INT));\n        tokenY.safeApprove(vault, uint256(MAX_INT));\n\n        //provide required lb token approvals\n        lbToken.setApprovalForAll(address(joeRouter), true);\n    }\n\n    /// @notice remove allowances for this strategy\n    function _removeAllowances() internal {\n        tokenX.safeApprove(joeRouter, 0);\n        tokenY.safeApprove(joeRouter, 0);\n\n        tokenX.safeApprove(vault, 0);\n        tokenY.safeApprove(vault, 0);\n\n        //revoke required lb token approvals\n        lbToken.setApprovalForAll(address(joeRouter), false);\n    }\n\n    /// @notice swaps tokens from the strategy\n    /// @param amountIn the amount of token that needs to be swapped\n    /// @param _swapForY is tokenX being swapped for tokenY\n    function _swap(\n        uint256 amountIn,\n        bool _swapForY\n    ) internal returns (uint256 amountOutReal) {\n        IERC20[] memory tokenPath = new IERC20[](2);\n\n        //set the required token paths\n        if (_swapForY) {\n            tokenPath[0] = tokenX;\n            tokenPath[1] = tokenY;\n        } else {\n            tokenPath[0] = tokenY;\n            tokenPath[1] = tokenX;\n        }\n\n        //compute the required bin step\n        uint256[] memory pairBinSteps = new uint256[](1);\n        pairBinSteps[0] = binStep;\n\n        //perform the swapping of tokens\n        amountOutReal = ILBRouter(joeRouter).swapExactTokensForTokens(\n            amountIn,\n            0,\n            pairBinSteps,\n            tokenPath,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function _harvest()\n        internal\n        returns (uint256 amountXReceived, uint256 amountYReceived)\n    {\n        //collects pending rewards\n        (amountXReceived, amountYReceived) = _collectRewards();\n\n        lastHarvest = block.timestamp;\n    }\n\n    /// @notice collects any availiable rewards from the pair\n    /// @return amountXReceived tokenX amount received\n    /// @return amountYReceived tokenY amount received\n    function _collectRewards()\n        internal\n        returns (uint256 amountXReceived, uint256 amountYReceived)\n    {\n        (uint256 amountXBefore, uint256 amountYBefore) = getTotalAmounts();\n\n        uint256[] memory activeBinIds = getActiveBinIds();\n\n        (amountXReceived, amountYReceived) = lbPair.collectFees(\n            address(this),\n            activeBinIds\n        );\n\n        (uint256 amountX, uint256 amountY) = getTotalAmounts();\n\n        //emit event fee's collected\n        emit CollectRewards(\n            lastHarvest,\n            amountXBefore,\n            amountYBefore,\n            amountX,\n            amountY\n        );\n    }\n\n    /// @notice helper safety check to see if distX and distY add to PRECISION\n    /// @param _distribution distributionX or distributionY to check\n    function _checkDistribution(uint256[] memory _distribution) internal pure {\n        uint256 total;\n\n        //loop over the distribution provided and make sure to sum to PRECISION\n        for (uint256 i; i < _distribution.length; ++i) {\n            total += _distribution[i];\n        }\n        require(total == PRECISION, 'Strategy: Distribution incorrect');\n    }\n\n    /// -----------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------\n\n    /// @notice puts any available tokenX or tokenY to work\n    /// @return amountX amount of token X added as liquidity\n    /// @return amountY amount of token Y added as liquidity\n    function earn()\n        external\n        onlyManager\n        returns (uint256 amountX, uint256 amountY)\n    {\n        uint256 balanceX = tokenX.balanceOf(address(this));\n        uint256 balanceY = tokenY.balanceOf(address(this));\n\n        //gas saving check if there is idle funds in the contract\n        require(\n            balanceX > 1e3 || balanceY > 1e3,\n            'Vault: Insufficient idle funds in strategy'\n        );\n\n        //require the amounts to be deposited into the correct bin distributions\n        (amountX, amountY) = _calculateAmountsPerformSwap(\n            deltaIds,\n            balanceX,\n            balanceY\n        );\n\n        //use the funds in the strategy to add liquidty.\n        if (amountX > 0 || amountY > 0) {\n            _addLiquidity(amountX, amountY, 0, 0);\n        }\n    }\n\n    /// @notice entrypoint for the vault to remove liquidity from the strategy\n    /// @param denominator proportion of liquidity to remove\n    /// @return amountX amount of tokenX removed from liquidity\n    /// @return amountY amount of tokenY removed from liquidity\n    function removeLiquidity(\n        uint256 denominator\n    ) external returns (uint256 amountX, uint256 amountY) {\n        require(msg.sender == vault, 'Strategy: !vault');\n        (amountX, amountY) = _removeLiquidity(denominator);\n    }\n\n    /// @notice harvest the rewards from the strategy\n    /// @return amountXReceived amount of tokenX received from harvest\n    /// @return amountYReceived amount of tokenY received from harvest\n    function harvest()\n        external\n        virtual\n        returns (uint256 amountXReceived, uint256 amountYReceived)\n    {\n        (amountXReceived, amountYReceived) = _harvest();\n        tokenX.safeTransfer(owner(), amountXReceived);\n        tokenY.safeTransfer(owner(), amountYReceived);\n    }\n\n    /// -----------------------------------------------------------\n    /// View functions\n    /// -----------------------------------------------------------\n\n    /// @notice get the active bins that the strategy currently holds liquidity in.\n    /// @return activeBinIds array of active binIds\n    function getActiveBinIds()\n        public\n        view\n        returns (uint256[] memory activeBinIds)\n    {\n        uint256 _userPositionNumber = strategyPositionNumber();\n        //init the new holder array\n        activeBinIds = new uint256[](_userPositionNumber);\n\n        //loop over user position index and retrieve the bin ids\n        for (uint256 i; i < _userPositionNumber; ++i) {\n            uint256 userPosition = strategyPositionAtIndex(i);\n            activeBinIds[i] = userPosition;\n        }\n\n        return (activeBinIds);\n    }\n\n    /// @notice Calculates the vault's total holdings of tokenX and tokenY - in\n    /// other words, how much of each token the vault would hold if it withdrew\n    /// all its liquidity from Trader Joe Dex V2.\n    /// @return totalX managed by the strategy\n    /// @return totalY managed by the strategy\n    function getTotalAmounts()\n        public\n        view\n        returns (uint256 totalX, uint256 totalY)\n    {\n        //add currently active tokens supplied as liquidity\n        (totalX, totalY) = LiquidityAmounts.getAmountsOf(\n            address(this),\n            strategyActiveBins(),\n            address(lbPair)\n        );\n\n        //add currently unused tokens\n        totalX += getBalanceX();\n        totalY += getBalanceY();\n    }\n\n    /// @notice checks if the deltaId's contain X liquidity\n    /// @param _deltaIds to check\n    /// @return hasXLiquidity if tokenX is required as liquidity by strategy\n    function binHasXLiquidity(\n        int256[] memory _deltaIds\n    ) public pure returns (bool hasXLiquidity) {\n        for (uint256 i; i < _deltaIds.length; i++) {\n            if (_deltaIds[i] >= 0) {\n                hasXLiquidity = true;\n                break;\n            }\n        }\n    }\n\n    /// @notice checks if the deltaId's contain Y liquidity\n    /// @param _deltaIds to check\n    /// @return hasYLiquidity if tokenY is required as liquidity by strategy\n    function binHasYLiquidity(\n        int256[] memory _deltaIds\n    ) public pure returns (bool hasYLiquidity) {\n        for (uint256 i; i < _deltaIds.length; i++) {\n            if (_deltaIds[i] <= 0) {\n                hasYLiquidity = true;\n                break;\n            }\n        }\n    }\n\n    /// @notice checks if there is rewards ready to be harvested from the pair\n    /// @param _increasingBinIds strictly increasing binIds to check rewards in\n    /// @return rewardsX amount of rewards available of tokenX\n    /// @return rewardsY amount of rewards available of tokenY\n    function rewardsAvailable(\n        uint256[] memory _increasingBinIds\n    ) external view returns (uint256 rewardsX, uint256 rewardsY) {\n        require(_increasingBinIds.length > 0, 'Strat: Supply valid ids');\n        //pending fees requires strictly increasing ids (require sorting off chain)\n        (rewardsX, rewardsY) = lbPair.pendingFees(\n            address(this),\n            _increasingBinIds\n        );\n    }\n\n    /// @notice Balance of tokenX in strategy not used in any position.\n    /// @return tokenXAmount amount of tokenX idle in the strat\n    function getBalanceX() public view returns (uint256) {\n        return tokenX.balanceOf(address(this));\n    }\n\n    /// @notice Balance of tokenY in strategy not used in any position.\n    /// @return tokenYAmount amount of tokenY idle in the strat\n    function getBalanceY() public view returns (uint256) {\n        return tokenY.balanceOf(address(this));\n    }\n\n    /// -----------------------------------------------------------\n    /// Manager / Owner functions\n    /// -----------------------------------------------------------\n\n    /// @notice called as part of strat migration.\n    /// Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, '!vault');\n\n        //add currently active tokens supplied as liquidity\n        (uint256 totalX, uint256 totalY) = LiquidityAmounts.getAmountsOf(\n            address(this),\n            strategyActiveBins(),\n            address(lbPair)\n        );\n\n        if (totalX > 0 || totalY > 0) {\n            _removeLiquidity(PRECISION);\n        }\n\n        uint256 tokenXBal = tokenX.balanceOf(address(this));\n        uint256 tokenYBal = tokenY.balanceOf(address(this));\n\n        tokenX.transfer(vault, tokenXBal);\n        tokenY.transfer(vault, tokenYBal);\n    }\n\n    /// @notice pauses deposits and withdraws all funds from third party systems.\n    function panic() external onlyOwner {\n        pause();\n\n        //add currently active tokens supplied as liquidity\n        (uint256 totalX, uint256 totalY) = LiquidityAmounts.getAmountsOf(\n            address(this),\n            strategyActiveBins(),\n            address(lbPair)\n        );\n\n        //if there is liquidity remove it from dex and hold in strat\n        if (totalX > 0 || totalY > 0) {\n            _removeLiquidity(PRECISION);\n        }\n    }\n\n    /// @notice pauses deposits and removes allowances\n    function pause() public onlyOwner {\n        _pause();\n        _removeAllowances();\n    }\n\n    /// @notice allows deposits into third part systems\n    function unpause() external onlyOwner {\n        _unpause();\n        _giveAllowances();\n    }\n\n    /// @notice allows removal of tokens if necessary\n    function removeTokens(address token) external onlyOwner {\n        uint256 tokenBal = ERC20(token).balanceOf(address(this));\n        if (tokenBal > 0) {\n            ERC20(token).transfer(vault, tokenBal);\n        }\n    }\n\n    /// -----------------------------------------------------------\n    /// Rebalance functions\n    /// -----------------------------------------------------------\n\n    /// @notice point of call to execute a rebalance of the strategy with the same params\n    /// @return amountX total amountX supplied after the rebalance\n    /// @return amountY total amountY supplied after the rebalance\n    function executeRebalance()\n        external\n        onlyManager\n        returns (uint256 amountX, uint256 amountY)\n    {\n        (amountX, amountY) = executeRebalance(\n            deltaIds,\n            distributionX,\n            distributionY,\n            idSlippage\n        );\n    }\n\n    /// @notice point of call to execute a rebalance of the strategy with new params\n    /// @param _deltaIds the distribution of liquidity around the active bin\n    /// @param _distributionX the distribution of tokenX liquidity around the active bin\n    /// @param _distributionY the distribution of tokenY liquidity around the active bin\n    /// @param _idSlippage slippage of bins acceptable\n    /// @return amountX total amountX supplied after the rebalance\n    /// @return amountY total amountY supplied after the rebalance\n    function executeRebalance(\n        int256[] memory _deltaIds,\n        uint256[] memory _distributionX,\n        uint256[] memory _distributionY,\n        uint256 _idSlippage\n    ) public onlyManager returns (uint256 amountX, uint256 amountY) {\n        //ensure that we are keeping to the 50 bin limit\n        require(\n            _deltaIds.length < 50,\n            'Strategy: Bins shall be limited to <50'\n        );\n\n        //check parameters are equal in length\n        require(\n            _deltaIds.length == _distributionX.length &&\n                _distributionX.length == _distributionY.length,\n            'Strategy: Unbalanced params'\n        );\n\n        //check the distributions are correct\n        if (binHasXLiquidity(_deltaIds)) {\n            _checkDistribution(_distributionX);\n        }\n\n        if (binHasYLiquidity(_deltaIds)) {\n            _checkDistribution(_distributionY);\n        }\n\n        (uint256 amountXBefore, uint256 amountYBefore) = getTotalAmounts();\n\n        //remove any liquidity from joeRouter and clear active bins set\n        if (strategyPositionNumber() > 0) {\n            _removeLiquidity(PRECISION);\n        }\n\n        //rebalance the strategy params\n        deltaIds = _deltaIds;\n        distributionX = _distributionX;\n        distributionY = _distributionY;\n        idSlippage = _idSlippage;\n\n        //calculate new amounts to deposit if existing deposits\n        if (amountXBefore > 0 || amountYBefore > 0) {\n            (amountX, amountY) = _calculateAmountsPerformSwap(\n                _deltaIds,\n                tokenX.balanceOf(address(this)),\n                tokenY.balanceOf(address(this))\n            );\n        }\n\n        //only add liquidity if strategy has funds\n        if (amountX > 0 || amountY > 0) {\n            _addLiquidity(amountX, amountY, 0, 0);\n        }\n\n        (amountX, amountY) = getTotalAmounts();\n\n        //emit event\n        emit Rebalance(amountXBefore, amountYBefore, amountX, amountY);\n    }\n\n    /// @notice aligns the tokens to the required strategy deltas\n    /// performs swaps on tokens not required for the bin offsets\n    /// @param _deltaIds the delta ids of the current strategy\n    /// @param _amountX the amount of tokenX in the strategy\n    /// @param _amountY the amount of tokenY in the strategy\n    /// @return amountX amount of tokenX to add as liquidity\n    /// @return amountY amount of tokenY to add as liquidity\n    function _calculateAmountsPerformSwap(\n        int256[] memory _deltaIds,\n        uint256 _amountX,\n        uint256 _amountY\n    ) internal returns (uint256 amountX, uint256 amountY) {\n        //only token y liquidity\n        if (!binHasXLiquidity(_deltaIds) && binHasYLiquidity(_deltaIds)) {\n            //swap X for Y\n            _swap(_amountX, true);\n            amountY = tokenY.balanceOf(address(this));\n            amountX = 0;\n        }\n        //only token x liquidity\n        if (!binHasYLiquidity(_deltaIds) && binHasXLiquidity(_deltaIds)) {\n            //swap Y for X\n            _swap(_amountY, false);\n            amountX = tokenX.balanceOf(address(this));\n            amountY = 0;\n        }\n        //if has both token x and token y liquidity\n        if (binHasYLiquidity(_deltaIds) && binHasXLiquidity(_deltaIds)) {\n            //if bins move too much we need to swap for both\n            //we want to minimise the swap amounts limit to 1%\n            //used to seed bins with a minimal amount of liquidity to reduce swap fee and slippage\n            if (_amountX == 0) {\n                //swap y for x (minimise amount, only to seed liquidity)\n                _swap((1 * _amountY) / 100, false);\n            }\n\n            if (_amountY == 0) {\n                //swap x for y (minimise amount, only to seed liquidity)\n                _swap((1 * _amountX) / 100, true);\n            }\n\n            //set the final amounts for deposits\n            amountX = tokenX.balanceOf(address(this));\n            amountY = tokenY.balanceOf(address(this));\n        }\n    }\n\n    /// @notice Returns whether this contract implements the interface defined by\n    /// `interfaceId` (true) or not (false)\n    /// @param _interfaceId The interface identifier\n    /// @return Whether the interface is supported (true) or not (false)\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\n        return\n            _interfaceId == type(ILBToken).interfaceId ||\n            _interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/vault/LBVaultNative.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport '../LB-periph/LiquidityAmounts.sol';\nimport '../LB/interfaces/ILBToken.sol';\n\nimport '../interfaces/IWrappedNative.sol';\nimport '../interfaces/ILBStrategy.sol';\n\ncontract LBVaultV1Native is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 constant PRECISION = 1e18;\n\n    // The strategy currently in use by the vault.\n    ILBStrategy public strategy;\n\n    // ERC20 token version of AVAX.\n    IWrappedNative public immutable wavax =\n        IWrappedNative(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n\n    /// -----------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------\n\n    event UpgradeStrat(address implementation);\n    event Deposit(\n        address user,\n        uint256 amountX,\n        uint256 amountY,\n        uint256 shares\n    );\n    event Withdraw(\n        address user,\n        uint256 amountX,\n        uint256 amountY,\n        uint256 shares\n    );\n\n    /// -----------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------\n\n    constructor(\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {}\n\n    /// -----------------------------------------------------------\n    /// AVAX PAIR HELPER FUNCTIONS\n    /// -----------------------------------------------------------\n\n    /// @notice Alternative entry point into the strat. You can send native AVAX,\n    /// and the vault will wrap them before depositing them into the strat.\n    /// @notice Deposits tokens in proportion to the vault's current holdings.\n    /// @param amountX amount of tokenX to deposit\n    /// @param amountY amount of tokenY to deposit\n    /// @param amountXMin miniumum amount of tokenX to deposit incl. slippage\n    /// @param amountYMin miniumum amount of tokenY to deposit incl. slippage\n    /// @return shares minted to the depoositor\n    /// @return amountXActual amount token X accepted as deposit\n    /// @return amountYActual amount token Y accepted as deposit\n    function depositAVAXPair(\n        uint256 amountX,\n        uint256 amountY,\n        uint256 amountXMin,\n        uint256 amountYMin\n    )\n        external\n        payable\n        returns (uint256 shares, uint256 amountXActual, uint256 amountYActual)\n    {\n        if (address(strategy.tokenX()) == address(wavax)) {\n            require(amountX == msg.value, 'Native: Amounts not equal');\n        }\n\n        if (address(strategy.tokenY()) == address(wavax)) {\n            require(amountY == msg.value, 'Native: Amounts not equal');\n        }\n\n        //wrap the required amount of AVAX to msg.sender\n        _wavaxDepositAndTransfer(address(msg.sender), msg.value);\n\n        //deposit required amounts\n        (shares, amountXActual, amountYActual) = deposit(\n            amountX,\n            amountY,\n            amountXMin,\n            amountYMin\n        );\n    }\n\n    /// @notice alternative exitpoint of native funds from the system. People withdraw from this function.\n    /// @param _shares amount of shares to withdraw from the system\n    /// @return amountX the amount of token X removed\n    /// @return amountY the amount of token Y removed\n    function withdrawAVAXPair(\n        uint256 _shares\n    ) public nonReentrant returns (uint256 amountX, uint256 amountY) {\n        require(_shares > 0, 'Vault: burn 0 not allowed');\n        require(_shares <= balanceOf(msg.sender));\n\n        //fetch the total supply of receipt tokens\n        uint256 totalSupply = totalSupply();\n\n        //Burn the shares that are being returned\n        _burn(msg.sender, _shares);\n\n        // Calculate token amounts proportional to unused balances\n        uint256 unusedAmountX = (strategy.getBalanceX() * _shares) /\n            totalSupply;\n        uint256 unusedAmountY = (strategy.getBalanceY() * _shares) /\n            totalSupply;\n\n        (uint256 totalX, uint256 totalY) = LiquidityAmounts.getAmountsOf(\n            address(strategy),\n            strategy.strategyActiveBins(),\n            address(strategy.lbPair())\n        );\n\n        //if liquidity is deployed remove in the correct proportion\n        //remove the liquidity in the correct proportion to the shares to be burnt\n        uint256 _amountX;\n        uint256 _amountY;\n        if (totalX > 0 || totalY > 0) {\n            uint256 removedDenominator = (PRECISION * totalSupply - 1) /\n                _shares +\n                1;\n\n            (_amountX, _amountY) = strategy.removeLiquidity(removedDenominator);\n        }\n\n        // Sum up total amounts owed to recipient\n        amountX = unusedAmountX + _amountX;\n        amountY = unusedAmountY + _amountY;\n\n        //transfer tokens back to the user\n        if (amountX > 0) {\n            //check for native\n            if (address(strategy.tokenX()) == address(wavax)) {\n                strategy.tokenX().safeTransferFrom(\n                    address(strategy), //from\n                    address(this), //to\n                    amountX //amount\n                );\n                //unwrap avax from this address\n                wavax.withdraw(amountX);\n                //send avax to the msg sender\n                _safeTransferAVAX(msg.sender, amountX);\n            } else {\n                strategy.tokenX().safeTransferFrom(\n                    address(strategy),\n                    address(msg.sender),\n                    amountX\n                );\n            }\n        }\n\n        if (amountY > 0) {\n            //check for native\n            if (address(strategy.tokenY()) == address(wavax)) {\n                strategy.tokenY().safeTransferFrom(\n                    address(strategy), //from\n                    address(this), //to\n                    amountY //amount\n                );\n                //unwrap avax from this address\n                wavax.withdraw(amountY);\n                //send avax to the msg sender\n                _safeTransferAVAX(msg.sender, amountY);\n            } else {\n                strategy.tokenY().safeTransferFrom(\n                    address(strategy),\n                    address(msg.sender),\n                    amountY\n                );\n            }\n        }\n\n        //emit an event\n        emit Withdraw(msg.sender, amountX, amountY, _shares);\n    }\n\n    /// @notice Helper function to transfer AVAX\n    /// @param _to The address of the recipient\n    /// @param _amount The AVAX amount to send\n    function _safeTransferAVAX(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}('');\n        require(success, 'VaultNative: Failed to Send AVAX');\n    }\n\n    /// @notice Helper function to deposit\n    /// @param _amount The AVAX amount to wrap\n    function _wavaxDeposit(uint256 _amount) private {\n        wavax.deposit{value: _amount}();\n    }\n\n    /// @notice Helper function to deposit and transfer wavax\n    /// @param _to The address of the recipient\n    /// @param _amount The AVAX amount to wrap\n    function _wavaxDepositAndTransfer(address _to, uint256 _amount) private {\n        wavax.deposit{value: _amount}();\n        IERC20(address(wavax)).safeTransfer(_to, _amount);\n    }\n\n    /// @dev Receive function that only accept AVAX from the WAVAX contract\n    receive() external payable {\n        require(\n            msg.sender == address(wavax),\n            'VaultNative: Sender not WAVAX contract'\n        );\n    }\n\n    /// -----------------------------------------------------------\n    /// Public functions\n    /// -----------------------------------------------------------\n\n    /// @notice primary entrypoint of funds into the system. users deposit with this function\n    /// into the vault. The vault is then in charge of sending funds into the strategy.\n    /// funds stay idle in the strategy until earn() is called on the strategy and valid parameters\n    /// @notice Deposits tokens in proportion to the vault's current holdings.\n    /// @param amountX amount of tokenX to deposit\n    /// @param amountY amount of tokenY to deposit\n    /// @param amountXMin miniumum amount of tokenX to deposit incl. slippage\n    /// @param amountYMin miniumum amount of tokenY to deposit incl. slippage\n    /// @return shares minted to the depoositor\n    /// @return amountXActual amount token X accepted as deposit\n    /// @return amountYActual amount token Y accepted as deposit\n    function deposit(\n        uint256 amountX,\n        uint256 amountY,\n        uint256 amountXMin,\n        uint256 amountYMin\n    )\n        public\n        nonReentrant\n        returns (uint256 shares, uint256 amountXActual, uint256 amountYActual)\n    {\n        require(amountX > 0 || amountY > 0, 'Vault: deposit cannot be 0');\n\n        //harvest any pending rewards to prevent flash theft of yield\n        if (totalSupply() != 0) {\n            strategy.harvest();\n        }\n\n        // Calculate amounts proportional to vault's holdings\n        (shares, amountXActual, amountYActual) = calcSharesAndAmounts(\n            amountX,\n            amountY\n        );\n\n        require(shares > 0, 'shares');\n        require(amountXActual >= amountXMin, 'amount0Min');\n        require(amountYActual >= amountYMin, 'amount1Min');\n\n        //transfer tokens required into the strategy\n        if (amountXActual > 0) {\n            strategy.tokenX().safeTransferFrom(\n                msg.sender,\n                address(strategy),\n                amountXActual\n            );\n        }\n\n        if (amountYActual > 0) {\n            strategy.tokenY().safeTransferFrom(\n                msg.sender,\n                address(strategy),\n                amountYActual\n            );\n        }\n\n        //mint vault shares at the required proportion of new liquidity supplied.\n        _mint(msg.sender, shares);\n\n        //emit a deposit event\n        emit Deposit(msg.sender, amountXActual, amountYActual, shares);\n    }\n\n    /// @notice a helper which will withdraw all of the users shares from the vault\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /// @notice primary exit point of funds from the system. users withdraw using this function.\n    /// @param _shares amount of shares to withdraw from the system\n    /// @return amountX the amount of token X removed\n    /// @return amountY the amount of token Y removed\n    function withdraw(\n        uint256 _shares\n    ) public nonReentrant returns (uint256 amountX, uint256 amountY) {\n        require(_shares > 0, 'Vault: burn 0 not allowed');\n        require(_shares <= balanceOf(msg.sender));\n\n        //fetch the total supply of receipt tokens\n        uint256 totalSupply = totalSupply();\n\n        //Burn the shares that are being returned\n        _burn(msg.sender, _shares);\n\n        // Calculate token amounts proportional to unused balances\n        uint256 unusedAmountX = (strategy.getBalanceX() * _shares) /\n            totalSupply;\n        uint256 unusedAmountY = (strategy.getBalanceY() * _shares) /\n            totalSupply;\n\n        (uint256 totalX, uint256 totalY) = LiquidityAmounts.getAmountsOf(\n            address(strategy),\n            strategy.strategyActiveBins(),\n            address(strategy.lbPair())\n        );\n\n        //if liquidity is deployed remove in the correct proportion\n        //remove the liquidity in the correct proportion to the shares to be burnt\n        uint256 _amountX;\n        uint256 _amountY;\n        if (totalX > 0 || totalY > 0) {\n            uint256 removedDenominator = (PRECISION * totalSupply - 1) /\n                _shares +\n                1;\n\n            (_amountX, _amountY) = strategy.removeLiquidity(removedDenominator);\n        }\n\n        // Sum up total amounts owed to recipient\n        amountX = unusedAmountX + _amountX;\n        amountY = unusedAmountY + _amountY;\n\n        //transfer tokens back to the user from the strategy\n        if (amountX > 0) {\n            strategy.tokenX().safeTransferFrom(\n                address(strategy),\n                address(msg.sender),\n                amountX\n            );\n        }\n\n        if (amountY > 0) {\n            strategy.tokenY().safeTransferFrom(\n                address(strategy),\n                address(msg.sender),\n                amountY\n            );\n        }\n\n        //emit an event\n        emit Withdraw(msg.sender, amountX, amountY, _shares);\n    }\n\n    /// -----------------------------------------------------------\n    /// View functions\n    /// -----------------------------------------------------------\n\n    /// @dev Calculates the largest possible `amountx` and `amountY` such that\n    /// they're in the same proportion as total amounts, but not greater than\n    /// `amountXDesired` and `amountYDesired` respectively.\n    function calcSharesAndAmounts(\n        uint256 amountXDesired,\n        uint256 amountYDesired\n    ) public view returns (uint256 shares, uint256 amountX, uint256 amountY) {\n        uint256 totalSupply = totalSupply();\n\n        //add currently active tokens supplied as liquidity\n        (uint256 totalX, uint256 totalY) = LiquidityAmounts.getAmountsOf(\n            address(strategy),\n            strategy.strategyActiveBins(),\n            address(strategy.lbPair())\n        );\n\n        //add currently unused tokens in the strategy\n        totalX += strategy.getBalanceX();\n        totalY += strategy.getBalanceY();\n\n        // If total supply > 0, vault can't be empty\n        assert(totalSupply == 0 || totalX > 0 || totalY > 0);\n\n        if (totalSupply == 0) {\n            // For first deposit, just use the amounts desired\n            amountX = amountXDesired;\n            amountY = amountYDesired;\n            shares = Math.max(amountX, amountY);\n        } else if (totalX == 0) {\n            amountY = amountYDesired;\n            shares = (amountY * totalSupply) / totalY;\n        } else if (totalY == 0) {\n            amountX = amountXDesired;\n            shares = (amountX * totalSupply) / totalX;\n        } else {\n            uint256 cross = Math.min(\n                (amountXDesired * totalY),\n                (amountYDesired * totalX)\n            );\n\n            require(cross > 0, 'cross');\n\n            // Round up amounts\n            amountX = (cross - 1) / totalY + 1;\n            amountY = (cross - 1) / totalX + 1;\n            shares = (cross * totalSupply) / totalX / totalY;\n        }\n    }\n\n    /// @notice returns the input tokens that may be deposited to this vault\n    /// @return tokenX address of first token\n    /// @return tokenY address of second token\n    function want() external view returns (IERC20, IERC20) {\n        return (strategy.tokenX(), strategy.tokenY());\n    }\n\n    /// @notice Gets the underlying assets in the vault i.e tokenX and tokenY\n    /// includes all tokenX and tokenY idle in the strategy and supplied as liquidity\n    /// @param _shares amount of shares\n    /// @return totalX amounts of tokenX\n    /// @return totalY amounts of tokenY\n    function getUnderlyingAssets(\n        uint256 _shares\n    ) external view returns (uint256 totalX, uint256 totalY) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return (0, 0);\n        }\n\n        //add currently active tokens supplied as liquidity\n        (totalX, totalY) = LiquidityAmounts.getAmountsOf(\n            address(strategy),\n            strategy.strategyActiveBins(),\n            address(strategy.lbPair())\n        );\n\n        //add currently unused tokens in the strategy\n        totalX += strategy.getBalanceX();\n        totalY += strategy.getBalanceY();\n\n        totalX = (totalX * _shares) / _totalSupply;\n        totalY = (totalY * _shares) / _totalSupply;\n    }\n\n    /// -----------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------\n\n    /// @notice Allows the vaults underlying strategy to be swapped out after first deploy\n    /// @param _strategy address of the proposed new strategy.\n    function setStrategyAddress(address _strategy) external onlyOwner {\n        require(\n            address(strategy) == 0x0000000000000000000000000000000000000000,\n            'Vault: Strategy already Set'\n        );\n        strategy = ILBStrategy(_strategy);\n        emit UpgradeStrat(_strategy);\n    }\n\n    /// @notice Rescues funds stuck\n    /// @param _token address of the token to rescue.\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n\n    /// @notice Rescues LB tokens funds stuck\n    /// @param _lbToken address of the token to rescue.\n    /// @param _id id of the token to rescue.\n    function inCaseLBTokensGetStuck(\n        address _lbToken,\n        uint256 _id\n    ) external onlyOwner {\n        uint256 amount = ILBToken(_lbToken).balanceOf(address(this), _id);\n        ILBToken(_lbToken).safeTransferFrom(\n            address(this),\n            msg.sender,\n            _id,\n            amount\n        );\n    }\n\n    /// -----------------------------------------------------------\n    /// END\n    /// -----------------------------------------------------------\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}